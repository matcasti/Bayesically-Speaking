[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Blog\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nNon-linear models: Pharmacokinetics and Indomethacin\n\n\n\n\n\n\nnon-linear\n\n\n\nHere we dive in the process of making a non-linear model to predict the decay of plasma levels of an anti-inflammatory drug, and compare frequentist and bayesian methods. \n\n\n\n\n\nAug 20, 2024\n\n\n15 min\n\n\n\n\n\n\n\n\n\n\n\n\nThe Good, The Bad, and Hamiltonian Monte Carlo\n\n\n\n\n\n\nmcmc\n\n\n\nFollowing the footsteps of the previous post, here we delve ourselves into the mud of hamiltonian mechanics and how its dynamics can help us to explore parameter space more efficiently. \n\n\n\n\n\nMay 15, 2024\n\n\n30 min\n\n\n\n\n\n\n\n\n\n\n\n\nMarkov Chain Monte What?\n\n\n\n\n\n\nintro\n\n\nmcmc\n\n\n\nIn this post we will delve into the main idea behind Markov Chain Monte Carlo (MCMC for short) and why it is useful within the bayesian inference framework. \n\n\n\n\n\nApr 25, 2024\n\n\n23 min\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome to Bayesically Speaking\n\n\n\n\n\n\nnews\n\n\n\nHi everyone! This is the first post of Bayesically Speaking, so get your seatbelt on and get ready to join me on this ride! \n\n\n\n\n\nJun 10, 2023\n\n\n12 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About"
  },
  {
    "objectID": "about.html#what-is-all-the-fuzz-about",
    "href": "about.html#what-is-all-the-fuzz-about",
    "title": "About",
    "section": "What is all the fuzz about?",
    "text": "What is all the fuzz about?\nHello and welcome to Bayesically Speaking, the blog where I, Matías, share my passion for statistics, bayesian methods and coffee. If you are curious about how to use data and probability to understand and solve real world problems, you have come to the right place. Here you will find practical examples, tutorials, tips and tricks on how to apply statistical thinking and inference to various domains and scenarios."
  },
  {
    "objectID": "about.html#who-is-this-guy",
    "href": "about.html#who-is-this-guy",
    "title": "About",
    "section": "Who is this guy?",
    "text": "Who is this guy?\nWho am I and why should you care? Well, I am a researcher who loves numbers and coffee (not necessarily in that order). I have a special interest in bayesian methods, which are a powerful and flexible way of doing statistics that allows you to incorporate prior knowledge and uncertainty into your analysis. Bayesian methods are not magic, though. They have their limitations and challenges, just like any other approach. That’s why I don’t shy away from using other tools when they are appropriate, such as frequentist methods or p-values. My goal is not to start a war between different schools of thought, but to show you how to use the best tool for the job."
  },
  {
    "objectID": "about.html#a-secret-weapon",
    "href": "about.html#a-secret-weapon",
    "title": "About",
    "section": "A secret weapon",
    "text": "A secret weapon\nIn this blog, you will also learn how to create beautiful and informative graphics and plots using R, which is a free and open source software for data analysis and visualization. R is my favorite tool for doing statistics, because it has a huge community of users and developers who create amazing packages and resources for all kinds of purposes. R can also do much more than just statistics, such as web scraping, text mining, machine learning and more. Even this website was build using R!"
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html",
    "href": "posts/2024-05-15 mcmc part 2/index.html",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "",
    "text": "Hey there, fellow science enthusiasts and stats geeks! Welcome back to the wild world of Markov Chain Monte Carlo (MCMC) algorithms. This is part two of my series on the powerhouse behind Bayesian Inference. If you missed the first post, no worries! Just hop on over here and catch up before we dive deeper into the MCMC madness. Today, we’re exploring the notorious Hamiltonian Monte Carlo (HMC), a special kind of MCMC algorithm that taps into the dynamics of Hamiltonian mechanics.\n\n\nHold up, did you say Hamiltonian mechanics? What in the world do mechanics and physics have to do with Bayesian stats? I get it, it sounds like a mashup of your wildest nightmares. But trust me, this algorithm sometimes feels like running a physics simulation in a statistical playground. Remember our chat from the last post? In Bayesian stats, we’re all about estimating the shape of a parameter space, aka the posterior distribution.\n\nFun fact: There’s this whole field called statistical mechanics where scientists mix stats and physics to solve cool problems, mostly related to thermodynamics and quantum mechanics.\n\n\n\n\nPicture this: You drop a tiny particle down a cliff, and it rolls naturally along the landscape’s curves and slopes. Easy, right? Now, swap out the real-world terrain for a funky high-dimensional probability function. That same little particle? It’s cruising through this wild statistical landscape like a boss, all thanks to the rules of Hamiltonian mechanics.\n\n\n\n\n\n\n\n\n\n\nAbout the animation\n\n\n\n\n\nThe previous animation illustrate the Hamiltonian dynamics of a particle traveling a two-dimensional parameter space. The code for this animation is borrowed from Chi Feng’s github. You can find the original repository with corresponding code here: https://github.com/chi-feng/mcmc-demo"
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html#stats-meets-physics",
    "href": "posts/2024-05-15 mcmc part 2/index.html#stats-meets-physics",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "",
    "text": "Hold up, did you say Hamiltonian mechanics? What in the world do mechanics and physics have to do with Bayesian stats? I get it, it sounds like a mashup of your wildest nightmares. But trust me, this algorithm sometimes feels like running a physics simulation in a statistical playground. Remember our chat from the last post? In Bayesian stats, we’re all about estimating the shape of a parameter space, aka the posterior distribution.\n\nFun fact: There’s this whole field called statistical mechanics where scientists mix stats and physics to solve cool problems, mostly related to thermodynamics and quantum mechanics."
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html#a-particle-rolling-through-stats-land",
    "href": "posts/2024-05-15 mcmc part 2/index.html#a-particle-rolling-through-stats-land",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "",
    "text": "Picture this: You drop a tiny particle down a cliff, and it rolls naturally along the landscape’s curves and slopes. Easy, right? Now, swap out the real-world terrain for a funky high-dimensional probability function. That same little particle? It’s cruising through this wild statistical landscape like a boss, all thanks to the rules of Hamiltonian mechanics.\n\n\n\n\n\n\n\n\n\n\nAbout the animation\n\n\n\n\n\nThe previous animation illustrate the Hamiltonian dynamics of a particle traveling a two-dimensional parameter space. The code for this animation is borrowed from Chi Feng’s github. You can find the original repository with corresponding code here: https://github.com/chi-feng/mcmc-demo"
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html#wrapping-our-heads-around-the-math",
    "href": "posts/2024-05-15 mcmc part 2/index.html#wrapping-our-heads-around-the-math",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "Wrapping Our Heads Around the Math",
    "text": "Wrapping Our Heads Around the Math\nOkay, I know Hamiltonian dynamics can be a real brain-buster — trust me, it took me a hot minute to wrap my head around it. But hey, I’ve got an analogy that might just make it click. Let’s revisit our swing scenario: remember our picture of a kid on a swing, right? The swing’s angle from the vertical (\\(q\\)) tells us where the kid is, and momentum (\\(p\\)) is how fast the swing’s moving.\nNow, let’s break down those equations:\n\\[\n\\frac{{dq}}{{dt}} = \\frac{{\\partial H}}{{\\partial p}}\n\\]\nThis one’s like peeking into the future to see how the angle (\\(q\\)) changes over time. And guess what? It’s all about momentum (\\(p\\)). The faster the swing’s going, the quicker it swings back and forth — simple as that!\nNext up:\n\\[\n\\frac{{dp}}{{dt}} = -\\frac{{\\partial H}}{{\\partial q}}\n\\]\nNow, this beauty tells us how momentum (\\(p\\)) changes over time. It’s all about the energy game here — specifically, how the swing’s position (\\(q\\)) affects its momentum. When the swing’s at the highest point, gravity’s pulling hardest, ready to send him back down.\nSo, picture this:\n\nThe kid swings forward, so the angle (\\(q\\)) goes up thanks to the momentum (\\(p\\)) building until bam — top of the swing.\nAt the top, the swing’s momentarily still, but gravity’s pulling to send him flying back down — hence, he is accumulating potential energy.\nZoom! Back down it goes, picking up speed in the opposite direction — and so, the potential energy is then transferred into kinetic energy.\n\nAll the while, the Hamiltonian (\\(H\\)) is keeping tabs on the swing’s total energy — whether it’s zooming at the bottom (high kinetic energy \\(K(p)\\), as a function of momentum \\(p\\)) or pausing at the top (high potential energy \\(U(q)\\), as a function of position \\(q\\)).\nThis dance between kinetic and potential energy is what we care within Hamiltonian mechanics, and also what we mean when we refer to the phase space, which it’s nothing more than the relationship between position and momentum."
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html#visualizing-hamiltons-equations",
    "href": "posts/2024-05-15 mcmc part 2/index.html#visualizing-hamiltons-equations",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "Visualizing Hamilton’s Equations",
    "text": "Visualizing Hamilton’s Equations\nOkay, I know we’re diving into some physics territory here in a stats blog, but trust me, understanding these concepts is key to unlocking what HMC’s all about. So, let’s take a little side trip and get a feel for Hamilton’s equations with a different example. Check out the gif below — see that weight on a string? It’s doing this cool back-and-forth dance thanks to the tug-of-war between the string pulling up and gravity pulling down.\n\n\n\nSimple harmonic oscillator. Within this example we could expect that the potential energy \\(U(q)\\) is the greatest at the bottom or top positions \\(q\\), primarely because is in these positions that the force exerted by the string is greater, affecting in consequence the kinetic energy \\(K(p)\\) of the mass attached at the bottom of the string.\n\n\nNow, let’s get a little hands-on with some code. We’re gonna simulate a simple harmonic oscillator — you know, like that weight on a string — and watch how it moves through phase space.\n\n# Define the potential energy function (U) and its derivative (dU/dq)\nU &lt;- function(q) {\n  k &lt;- 1  # Spring constant\n  return(0.5 * k * q^2)\n}\n\n\ndU_dq &lt;- function(q) {\n  k &lt;- 1  # Spring constant\n  return(k * q)\n}\n\n# Kinetic energy (K) used for later\nK &lt;- function(p, m) {\n  return(p^2 / (2 * m))\n}\n\n# Introduce a damping coefficient\nb &lt;- 0.1  # Damping coefficient\n\n# Set up initial conditions\nq &lt;- -3.0  # Initial position\np &lt;- 0.0   # Initial momentum\nm &lt;- 1.0   # Mass\n\n# Time parameters\nt_max &lt;- 20\ndt &lt;- 0.1\nnum_steps &lt;- ceiling(t_max / dt)  # Ensure num_steps is an integer\n\n# Initialize arrays to store position and momentum values over time\nq_values &lt;- numeric(num_steps)\np_values &lt;- numeric(num_steps)\n\n# Perform time integration using the leapfrog method\nfor (i in 1:num_steps) {\n  # Store the current values\n  q_values[i] &lt;- q\n  p_values[i] &lt;- p\n  \n  # Half step update for momentum with damping\n  p_half_step &lt;- p - 0.5 * dt * (dU_dq(q) + b * p / m)\n  \n  # Full step update for position using the momentum from the half step\n  q &lt;- q + dt * (p_half_step / m)\n  \n  # Another half step update for momentum with damping using the new position\n  p &lt;- p_half_step - 0.5 * dt * (dU_dq(q) + b * p_half_step / m)\n}\n\n\nIn this code:\n\nU is the potential energy function, kinda like how much energy’s stored in that spring, if you will.\nK is the kinetic energy function, telling us how much energy’s tied up in the speed of the weight.\ndU_dq is telling us about how the potential energy changes with the weight’s position, aka the force.\nb is just a fancy way of saying how much energy the system loses over time.\nq and p are the weight’s position and momentum, respectively.\nm is the weight’s mass, nothing fancy.\ndt is the time step, and num_steps? Well, that’s just how long we’re gonna keep this simulation running.\nOh, and that leapfrog integration? It’s like stepping through time, updating the momentum, then the position, and back again — but don’t worry about it, we’ll see it shortly.\n\n\n\n\nCode\nharmonic_data &lt;- data.table(`Position (q)` = q_values, `Momentum (p)` = p_values)\n\nggplot(harmonic_data, aes(`Position (q)`, `Momentum (p)`)) +\n  geom_path(linewidth = .7) +\n  geom_point(size = 2) +\n  geom_point(data = harmonic_data[1,], col = \"red\", size = 3) +\n  labs(title = \"Phase Space Trajectory of Hamiltonian Dynamics\",\n       subtitle = \"Accounting for Energy Loss\") +\n  theme_classic(base_size = 20)\n\n\n\n\n\n\n\n\n\n\nCheck out this funky phase space trajectory of a simple harmonic oscillator! At the furthest points, the potential energy is the highest — that’s what’s driving the oscillator back and forth. But in the middle? That’s where the kinetic energy’s taking over, keeping things moving — like our example of a kid on a swing!\n\nNow, take a look at that graphic. See how the position (\\(q\\)) is all about where the oscillator’s hanging out, and momentum (\\(p\\))? Well, that’s just how fast the weight’s swinging. Put them together, and you’ve got what we call the phase space — basically, it’s like peeking into the dance floor of these mechanical systems through the lenses of Hamiltonian dynamics.\nNow, in a perfect world, there’d be no energy lost over time. But hey, we like to keep it real, so we added a little something called damping effect — think of it like energy leaking out of the system over time. In the real world, that makes sense, but in our statistical playground, we want to keep that energy locked in tight. After all, losing energy means we’re losing precious info about our target distribution, and nobody wants that.\n\n\nCode\nhamiltonian &lt;- harmonic_data[, list(`Total energy` = U(`Position (q)`) + K(`Momentum (p)`, m),\n                                    `Kinetic energy` = K(`Momentum (p)`, m), \n                                    `Potential energy` = U(`Position (q)`))]\nhamiltonian &lt;- melt(hamiltonian, measure.vars = c(\"Total energy\", \"Kinetic energy\", \"Potential energy\")) \n\nggplot(hamiltonian, aes(rep(1:200, times = 3), value, col = variable)) +\n  geom_line(linewidth = 1) +\n  labs(y = \"Energy\", col = \"Variable\", x = \"Time\",\n       title = \"Fluctuation of the Total Energy in the Oscillator\",\n       subtitle = \"As a Function of Kinetic and Potential Energy\") +\n  scale_color_brewer(type = \"qual\", palette = 2) +\n  theme_classic(base_size = 20) +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\nCheck out this energy rollercoaster! This graph’s showing us how the total energy — made up of kinetic and potential energy — changes over time. And yep, that damping effect? It’s keeping things realistic, but in stats land, we’re all about conserving that energy for our exploration.\n\nSo, what’s the big takeaway here? Well, whether it’s a ball rolling down a hill or a sampler hunting for model coefficients, this framework’s got us covered. In Bayesian land, think of our model’s parameters as position coordinates \\(q\\) in some space, and \\(p\\) is the momentum helping us navigate the twists and turns of this parameter space. And with Hamiltonian dynamics leading the way, we’re guaranteed to find our path through this statistical dimension, one step at a time."
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html#cooking-up-some-data",
    "href": "posts/2024-05-15 mcmc part 2/index.html#cooking-up-some-data",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "Cooking Up Some Data",
    "text": "Cooking Up Some Data\nBut before we dive into the statistical kitchen, let’s whip up some synthetic data. Picture this: we’re mimicking a real-world scenario where relationships between variables are as murky as a foggy morning. So, we’re gonna conjure up a batch of data with a simple linear relationship, jazzed up with a sprinkle of noise. Oh, and let’s keep it small — just 20 subjects, ’cause, hey, science “loves” a manageable sample size.\n\nEmphasis on double quotes on “loves”.\n\n\nset.seed(80) # Set seed for reproducibility\n\n# Define the number of data points and the range of independent variable 'x'\nn &lt;- 20\nx &lt;- seq(1, 10, length.out = n)\n\nOkay, so now let’s get down to business and fit ourselves a nice, cozy linear relationship between an independent variable (\\(x\\)) and a dependent variable (\\(y\\)). We’re talking about laying down a straight line that best describes how \\(y\\) changes with \\(x\\).\nSo, what’s our equation look like? Well, it’s pretty simple:\n\\[\n\\begin{aligned}\ny_i &\\sim \\mathcal{N}(\\mu_i, \\sigma^2) \\\\\n\\mu_i &= \\beta_0 + \\beta_1 \\cdot x_i \\\\\n\\end{aligned}\n\\]\nHold on, let’s break it down. We’re saying that each \\(y\\) value (\\(y_i\\)) is chillin’ around a mean (\\(\\mu_i\\)), like a bunch of friends at a party. And guess what? They’re all acting like good ol’ normal folks, hanging out with a variance (\\(\\sigma^2\\)) that tells us how spread out they are. Now, the cool part is how we define \\(\\mu_i\\). It’s just a simple sum of an intercept (\\(\\beta_0\\)) and the slope (\\(\\beta_1\\)) times \\(x_i\\). Think of it like plotting points on graph paper — each \\(x_i\\) tells us where we are on the \\(x\\)-axis, and multiplying by \\(\\beta_1\\) gives us the corresponding height on the line.\nNow, let’s talk numbers. We’re setting \\(\\beta_0\\) to 2 because, hey, every relationship needs a starting point, right? And for \\(\\beta_1\\), we’re going with 3 — that’s the rate of change we’re expecting for every unit increase in \\(x\\). Oh, and let’s not forget about \\(\\sigma\\) — that’s just a fancy way of saying how much our \\(y\\) values are allowed to wiggle around.\n\n# Define the true parameters of the linear model and the noise level\ntrue_intercept &lt;- 2\ntrue_slope &lt;- 3\nsigma &lt;- 5\n\nWith our model all set up, it’s time to create some data points for our \\(y\\) variable. We’ll do this using the rnorm() function, which is like a magical data generator for normally distributed variables.\n\n# Generate the dependent variable 'y' with noise\nmu_i = true_intercept + true_slope * x\ny &lt;- rnorm(n, mu_i, sigma)"
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html#choosing-a-target-distribution",
    "href": "posts/2024-05-15 mcmc part 2/index.html#choosing-a-target-distribution",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "Choosing a Target Distribution",
    "text": "Choosing a Target Distribution\nAlright, now that we’ve got our hands on some data, it’s time to dive into the nitty-gritty of Bayesian stuff. First up, we’re gonna need our trusty log likelihood function for our linear model. This function’s like the Sherlock Holmes of statistics — it figures out the probability of seeing our data given a specific set of parameters (you know, the intercept and slope we’re trying to estimate).\n\n# Define the log likelihood function for linear regression\nlog_likelihood &lt;- function(intercept, slope, x, y, sigma) {\n  \n  # We estimate the predicted response\n  y_pred &lt;- intercept + slope * x \n  \n  # Then we see how far from the observed value we are\n  residuals &lt;- y - y_pred\n  \n  # Then we estimate the likelihood associated with that error from a distribution\n  # with no error (mean = 0)\n  # (this is the function that we are trying to maximize)\n  log_likelihood &lt;- sum( dnorm(residuals, mean = 0, sd = sigma, log = TRUE) )\n  \n  return(log_likelihood)\n}\n\nSo, what’s the deal with priors? Well, think of them as the background music to our data party. They’re like our initial hunches about what the parameters could be before we’ve even glanced at the data. To keep things simple, we’ll go with flat priors — no favoritism towards any particular values. It’s like saying, “Hey, let’s give everyone a fair shot!”\n\n# Define the log prior function for the parameters\nlog_prior &lt;- function(intercept, slope) {\n  # Assuming flat priors for simplicity\n  # (the log of 0 is 1, so it has no effect)\n  return(0) \n}\n\nNow, here’s where the real magic kicks in. We bring our likelihood and priors together in a beautiful dance to reveal the superstar of Bayesian statistics — the posterior distribution! This bad boy tells us everything we wanna know after we’ve taken the data into account. This allow us to take into account previous knowledge — like past research, and the observed data — let’s say, samples from a new experiment.\nThe posterior it’s nothing more than the probability associated with our parameters of interest (aka. the slope and intercept), given the observed data. We represent this posterior distribution as the following:\n\\[\nP(\\text{X}|\\text{Data}) \\propto P(\\text{Data}|\\text{X}) \\times P(\\text{X})\n\\]\nWhich is the same as saying:\n\\[\n\\text{Posterior} \\propto \\text{Likelihood} \\times \\text{Prior}\n\\]\n\n# Combine log likelihood and log prior to get log posterior\nlog_posterior &lt;- function(intercept, slope, x, y, sigma) {\n  return(log_likelihood(intercept, slope, x, y, sigma) + log_prior(intercept, slope))\n}"
  },
  {
    "objectID": "posts/2024-05-15 mcmc part 2/index.html#building-the-hmc-sampler",
    "href": "posts/2024-05-15 mcmc part 2/index.html#building-the-hmc-sampler",
    "title": "The Good, The Bad, and Hamiltonian Monte Carlo",
    "section": "Building the HMC sampler",
    "text": "Building the HMC sampler\nAlright, now that we have everything ready, let’s dig into the guts of HMC and how we put it to work. Remember how HMC takes inspiration from the momentum and potential energy dance in physics? Well, in practice, it’s like having a GPS for our parameter space, guiding us to new spots that are more likely than others.\nBut here’s the thing: our parameter space isn’t some smooth highway we can cruise along endlessly. Nope, it’s more like a rugged terrain full of twists and turns. So, how do we navigate this space? Enter the leapfrog integration method, the backbone of HMC.\n\nLeapfrog Integration\nSo, leapfrog integration is basically this cool math trick we use in HMC to play out how a system moves over time using discrete steps, so we don’t have to compute every single value along the way. This integration method also is advantageous by not allowing energy leaks out of the system — remember the Hamiltonian? — which is super important if you don’t want to get stuck in this statistical dimension mid exploration.\nHere’s how it works in HMC-lingo: we use leapfrog integration to move around the parameter space in discrete steps — rather than sliding through a continuum, and grabbing samples from the posterior distribution. The whole process goes like this:\n\nWe give the momentum \\(p\\) a little nudge by leveraging on the gradient info (\\(\\nabla\\)). The gradient or slope of the position (\\(\\nabla U(q)\\)) in this parameter space will determine by how much our momentum will change. Like when we are in the top position in the swing — the potential energy then transfers to kinetic energy (aka. momentum).\nWe adjust the position (or parameters) based on the momentum boost.\nThen we update the momentum based on the gradient on that new position.\nWe repeat the cycle for as many “jumps” we are doing, for each sample of the posterior we intend to draw.\n\nPicture a frog hopping from one lily pad to another — that’s where the name “leapfrog” comes from. It helps us explore new spots in the parameter space by discretizing the motion of this imaginary particle by using Hamiltonian dynamics, using the slope information (\\(\\nabla U(q)\\)) of the current position \\(q\\) to gain/loss momentum \\(p\\) and move to another position \\(q\\) in the parameter space.\n\n\n\nA frog jumping, with a fixed step size, from one point in the phase space into another.\n\n\nWe prefer leapfrogging over simpler methods like Euler’s method because it keeps errors low, both locally and globally. This stability is key, especially when we’re dealing with big, complicated systems. Plus, it’s a champ at handling high-dimensional spaces, where keeping energy in check is a must for the algorithm to converge.\n\n\nTuning Those Hamiltonian Gears\nNow, to get our HMC sampler purring like a kitten, we’ve got to fine-tune a few gears. Think of these as the knobs and dials on your favorite sound system – adjust them just right, and you’ll be grooving to the perfect beat.\nFirst up, we’ve got the number of samples. This determines how many times our sampler will take a peek at the parameter space before calling it a day.\nNext, we’ve got the step size (\\(\\epsilon\\)). Imagine this as the stride length for our leapfrog integrator. Too short, and we’ll be tiptoeing; too long, and we’ll be taking giant leaps – neither of which gets us where we want to go. It’s all about finding that sweet spot.\nThen, there’s the number of steps for the leapfrog to make. Too few, and we risk missing key spots; too many, and we might tire ourselves out.\nLastly, we need an initial guess for the intercept and slope. This is like dropping a pin on a map – it gives our sampler a starting point to begin its journey through the parameter space.\n\n# Initialization of the sampler\nnum_samples &lt;- 5000  # Number of samples\nepsilon &lt;- 0.05  # Leapfrog step size\nnum_steps &lt;- 50  # Number of leapfrog steps\ninit_intercept &lt;- 0  # Initial guess for intercept\ninit_slope &lt;- 0  # Initial guess for slope\n\n# Placeholder for storing samples\nparams_samples &lt;- matrix(NA, nrow = num_samples, ncol = 2)\n\n\n\nStarting the Sampler\nAlright, let’s fire up this Hamiltonian engine and get this party started. Here’s the game plan:\n\nCreate a Loop: We’ll set up a loop to simulate our little particle moving around the parameter space.\nIntegrate Its Motion: Using our trusty leapfrog integrator, we’ll keep track of how our particle moves.\nGrab a Sample: Once our particle has finished its dance, we’ll grab a sample at its final position.\nAccept or Reject: We’ll play a little game of accept or reject – if the new position looks promising, we’ll keep it; if not, we’ll stick with the old one. It’s like Tinder for parameters.\nRepeat: We’ll rinse and repeat this process until we’ve collected as many samples as we need.\n\nNow, to kick things off, we’ll give our imaginary particle a random speed and direction to start with, and drop it down somewhere in the parameter space. This initial kick sets the stage for our parameter exploration, the rest is up to the physics.\nfor (i in 1:num_samples) {\n  # Start with a random momentum of the particle\n  momentum_current &lt;- rnorm(2)\n  \n  # And set the initial position of the particle\n  params_proposed &lt;-c(init_intercept, init_slope) \n  \n  # Next, we will simulate the particle's motion using\n  # leapfrog integration.\n  ...\n\nHere, I’m using the concept of a particle moving through a probability space. But remember, in reality, we’re talking about the parameter space, where each coefficient in a model parameter or any other parameter that we can represent in this way then becomes a coordinate — therefore, a position \\(q\\), in this statistical space.\n\n\n\nSimulating the Particle’s Motion\nNow that our imaginary particle is all geared up with an initial momentum and position, it’s time to let it loose and see where it goes in this parameter playground. We know we’re using Hamiltonian mechanics, but to make it computationally feasible, we’re bringing in our trusty leapfrog integrator. We’ve already seen that this bad boy discretizes the motion of our particle, making it manageable to track its journey without breaking our computers.\n\n\n\nMarble rolling over a surface. In a perfect world, we’d love to follow our particle smoothly gliding through the parameter space, but hey, computing that would take ages. So instead, we chunk its movement into smaller steps, kind of like a flipbook, to keep tabs on its position.\n\n\nSo, here’s the lowdown on what our leapfrog integrator is up to:\n\nEstimating the Slope: We start off with an initial position and estimate the slope of the terrain at that point.\n\n\\[\n\\nabla U(q) = \\frac{\\partial U}{\\partial q}\n\\]\n\nHere, we calculate the gradient \\(\\nabla\\) with respect of the current position \\(q\\)\n\n\nAdjusting Momentum: This slope is like the potential energy, dictating whether our particle speeds up or slows down. So, we tweak the momentum accordingly based on this slope.\n\n\\[\np \\leftarrow p - \\frac{\\epsilon}{2} \\cdot \\nabla U(q)\n\\]\n\nThen, we update the momentum \\(p\\) with the gradient \\(\\nabla U(q)\\) by half step (\\(\\frac{\\epsilon}{2}\\))\n\n\nTaking a Step: With this momentum tweak, we move the particle for a set distance \\(\\epsilon\\), updating its position from the starting point.\n\n\\[\nq \\leftarrow q - \\epsilon \\cdot p\n\\]\n\nRepeat: Now that our particle has a new spot, we rinse and repeat – estimating the slope and adjusting momentum.\n\n\\[\np \\leftarrow p - \\frac{\\epsilon}{2} \\cdot \\nabla U(q)\n\\]\n\nHere, we update momentum \\(p\\) by the other half step size on the new position \\(q\\)\n\n\nKeep Going: We keep this cycle going for as many steps as we want to simulate, tracking our particle’s journey through the parameter space.\n\nfor (j in 1:num_steps) {\n    # Gradient estimation\n    grad &lt;- c(\n      # Gradient of the intercept of X: -sum(residuals / variance)\n      ...\n      # Gradient of the slope of X: -sum(residuals * X / variance)\n      ...\n    )\n    \n    # Momentum half update\n    momentum_current &lt;- momentum_current - epsilon * grad * 0.5\n    \n    # Full step update for parameters\n    params_proposed &lt;- params_proposed + epsilon * momentum_current\n    \n    # Recalculate gradient for another half step update for momentum\n    grad &lt;- c(\n      # Gradient of the intercept of X: -sum(residuals / variance)\n      ...\n      # Gradient of the slope of X: -sum(residuals * X / variance)\n      ...\n    )\n    \n    # Final half momentum update\n    momentum_current &lt;- momentum_current - epsilon * grad * 0.5\n  }\n\n\nSample Evaluation and Acceptance\nAfter our particle has taken its fair share of steps through the parameter space, it’s decision time – should we accept or reject its proposed new position? We can’t just blindly accept every move it makes; we’ve got to be smart about it.\nThat’s where the Metropolis acceptance criteria come into play. This handy rule determines whether a proposed new position is a good fit or not. The idea is to weigh the probability of the new position against the probability of the current one. If the new spot looks promising, we’ll move there with a certain probability, ensuring that our samples accurately reflect the shape of the distribution we’re exploring. But if it’s not a better fit, we’ll stick with where we are.\nThe formula for this acceptance probability (\\(A(q', q)\\)) when transitioning from the current position (\\(q\\)) to a proposed position (\\(q'\\)) is straightforward:\n\\[\nA(q',q) = min(1,\\frac{p(q')}{p(q)})\n\\]\nHere, \\(p(q')\\) is the probability density of the proposed position \\(q'\\), and \\(p(q)\\) is the probability density of the current position \\(q\\). We’re essentially comparing the fitness of the proposed spot against where we’re currently at. If the proposed position offers a higher probability density, we’re more likely to accept it. This ensures that our samples accurately represent the target distribution.\nHowever, when dealing with very small probability values, we might run into numerical underflow issues. That’s where using the log posterior probabilities comes in handy. By taking the logarithm of the probabilities, we convert the ratio into a difference, making it easier to manage. Here’s how the acceptance criteria look with logarithms:\n\\[\n\\begin{aligned}\n\\alpha &= \\log(p(q')) - \\log(p(q)) \\\\\nA(q',q) &= min(1,exp(\\alpha))\n\\end{aligned}\n\\]\nThis formulation is equivalent to the previous one but helps us avoid numerical headaches, especially when working with complex or high-dimensional data. We’re still comparing the fitness of the proposed position with our current spot, just in a more log-friendly way.\n# Calculate log posteriors and acceptance probability\nlog_posterior_current &lt;- log_posterior( ...current parameters... )\nlog_posterior_proposed &lt;- log_posterior( ...proposed parameters... )\n\nalpha &lt;- min(1, exp(log_posterior_proposed - log_posterior_current))\n\n# Accept or reject the proposal\nif (runif(1) &lt; alpha) {\n  init_intercept &lt;- params_proposed[1]\n  init_slope &lt;- params_proposed[2]\n}\n\n\nMixing All Toghether\nNow that we’ve broken down each piece of our HMC puzzle, it’s time to put them all together and see how the full algorithm works.\n\nfor (i in 1:num_samples) {\n  # Randomly initialize momentum\n  momentum_current &lt;- rnorm(2)\n  \n  # Make a copy of the current parameters\n  params_proposed &lt;- c(init_intercept, init_slope)\n  \n  # Perform leapfrog integration\n  for (j in 1:num_steps) {\n    # Half step update for momentum\n    grad &lt;- c(\n      -sum((y - (params_proposed[1] + params_proposed[2] * x)) / sigma^2),\n      -sum((y - (params_proposed[1] + params_proposed[2] * x)) * x / sigma^2)\n    )\n    momentum_current &lt;- momentum_current - epsilon * grad * 0.5\n    \n    # Full step update for parameters\n    params_proposed &lt;- params_proposed + epsilon * momentum_current\n    \n    # Recalculate gradient for another half step update for momentum\n    grad &lt;- c(\n      -sum((y - (params_proposed[1] + params_proposed[2] * x)) / sigma^2),\n      -sum((y - (params_proposed[1] + params_proposed[2] * x)) * x / sigma^2)\n    )\n    momentum_current &lt;- momentum_current - epsilon * grad * 0.5\n  }\n  \n  # Calculate the log posterior of the current and proposed parameters\n  log_posterior_current &lt;- log_posterior(init_intercept, init_slope, x, y, sigma)\n  log_posterior_proposed &lt;- log_posterior(params_proposed[1], params_proposed[2], x, y, sigma)\n  \n  # Calculate the acceptance probability\n  alpha &lt;- min(1, exp(log_posterior_proposed - log_posterior_current))\n  \n  # Accept or reject the proposal\n  if (runif(1) &lt; alpha) {\n    init_intercept &lt;- params_proposed[1]\n    init_slope &lt;- params_proposed[2]\n  }\n  \n  # Save the sample\n  params_samples[i, ] &lt;- c(init_intercept, init_slope)\n}"
  },
  {
    "objectID": "posts/2024-08-05 non-linear-models part 1/index.html",
    "href": "posts/2024-08-05 non-linear-models part 1/index.html",
    "title": "Non-linear models: Pharmacokinetics and Indomethacin",
    "section": "",
    "text": "Let’s be honest, being a statistician or a scientist isn’t just about crunching numbers all day. It’s more like being a detective, a problem solver, and yeah, throwing in some math for good measure. When we get into non-linear models, things really start to get interesting. We’re not just drawing straight lines anymore; we’re wrestling with curves, untangling complicated relationships, and trying to figure out what’s really going on behind the scenes.\nTake pharmacokinetics, for example. Sounds fancy, right? But at the core, it’s just about what happens to a drug inside the body, and for us, that’s where the real statistical fun begins. Predicting how a drug’s concentration changes in the bloodstream over time isn’t just about plotting some points and calling it a day. It’s about understanding how the data dances with biology, and then figuring out the best way to describe that dance. And let’s not forget the little thrill of choosing your weapon: Frequentist or Bayesian? It’s like deciding between coffee or mate (and let’s be real, I’m down for both). Each one has its perks, but the choice depends on the situation—and maybe how you’re feeling that day.\nIn this post, we’re going to roll up our sleeves and dig into building a non-linear model to predict how something—let’s say, a drug disappears from the bloodstream. But we’re not stopping there. Nope, we’re also going to throw in a showdown between two big players: the frequentist and Bayesian methods. Think of it like a friendly face-off between two old rivals, each with its own style, strengths, and die-hard fans.\nBut here’s the thing: this isn’t just about which method wins on paper. It’s about the real-life, day-to-day grind of working with data. It’s about those moments when you’re staring at your screen, trying to make sense of a stubborn parameter that just won’t cooperate. It’s about knowing when to trust the numbers and when to rely on your gut, your experience, and maybe even a bit of luck.\nSo whether you’re a seasoned pro who’s been around the block or someone just dipping their toes into the world of applied stats, this post is for you. We’re going to dive in, compare, and yeah, maybe even have a little fun along the way. Because in the world of science and stats, the journey is half the adventure."
  },
  {
    "objectID": "posts/2024-08-05 non-linear-models part 1/index.html#designing-a-solution",
    "href": "posts/2024-08-05 non-linear-models part 1/index.html#designing-a-solution",
    "title": "Non-linear models: Pharmacokinetics and Indomethacin",
    "section": "Designing a solution",
    "text": "Designing a solution\nIt appears that the concentration of indomethacin decreases according to an inverse exponential function of time. We can model this relationship with:\n\\[\n\\begin{aligned}\ny_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\alpha + \\beta \\cdot \\exp(\\lambda \\cdot time_i)\n\\end{aligned}\n\\]\nIn this model, \\(\\lambda\\) represents the rate of decay in the plasma concentration of indomethacin (\\(y_i\\)), starting from a baseline concentration (\\(\\beta\\)). The term \\(\\alpha\\) estimates the minimum plasma concentration level over the observed time frame. We assume that the variance is constant across expected indomethacin plasma concentrations (\\(\\mu\\)) for each subject (\\(i\\)).\nHowever, given that we have repeated measurements from multiple individuals, we need to account for variability in the initial plasma concentrations across subjects. To address this, we introduce a random effect (\\(\\phi_i\\)) into the model:\n\\[\n\\begin{aligned}\n\\mu_i &= \\alpha + (\\beta + \\phi_i) \\cdot \\exp(\\lambda \\cdot time_i)\n\\end{aligned}\n\\]\nHere, \\(\\phi_i\\) represents the deviation from the baseline plasma level (\\(\\beta\\)) for subject \\(i\\). We keep \\(\\lambda\\) and \\(\\alpha\\) fixed because we’re interested in estimating population parameters to describe the pharmacokinetics of the drug."
  },
  {
    "objectID": "posts/2024-08-05 non-linear-models part 1/index.html#nlme-approach",
    "href": "posts/2024-08-05 non-linear-models part 1/index.html#nlme-approach",
    "title": "Non-linear models: Pharmacokinetics and Indomethacin",
    "section": "nlme approach",
    "text": "nlme approach\nLet’s dive into fitting a non-linear model using the nlme R package, which allows us to specify custom model forms:\n\nnlm_freq &lt;- nlme::nlme(\n  ## Model previously described\n  model = conc ~ alpha + (beta + phi) * exp(lambda * time),\n  data = Indometh,\n  ## Fixed effects\n  fixed = alpha + beta + lambda ~ 1,\n  ## Random effects\n  random = phi ~ 1 | Subject, \n  ## Starting proposal values\n  start = list(fixed = c(0, 2, -1)))\n\n## Confidence intervals for fixed effects\nnlme::intervals(nlm_freq, which = \"fixed\")\n\nApproximate 95% confidence intervals\n\n Fixed effects:\n             lower       est.      upper\nalpha   0.09050133  0.1311638  0.1718262\nbeta    2.36887258  2.8249635  3.2810543\nlambda -1.77509197 -1.6140483 -1.4530047\n\n\nLet’s kick things off by looking at where we stand with indomethacin’s plasma levels. At time zero, we’re seeing baseline concentrations hovering around 2.74 mcg/ml. Not too shabby, right? But this little molecule doesn’t stick around for long—our decay rate clocks in at about \\(\\exp(-1.61) \\approx 0.20\\), which translates to a swift 80% drop in those levels each hour. Eventually, the levels bottom out at around 0.13 mcg/ml, where the decline takes a bit of a breather.\nNow, if you were paying close attention to the code, you might have noticed something interesting: when we’re playing in the frequentist sandbox, particularly with non-linear models, we’ve got to give the algorithm a little nudge with some starting values. It’s like setting up the board for a game—these initial values are where the algorithm begins its quest through the likelihood landscape, hunting down the most likely parameters that explain our data. Remember that previous post about Hamiltonian Monte Carlo? Well, this is a bit like rolling a ball down a hill of parameter space, but here we’re aiming to land on the single spot that maximizes our chances of observing the data we have.\nBut enough with the theory, let’s dive back into our non-linear model and see how these predicted plasma levels measure up against the real-world data we’ve got in hand:\n\nfreq_pred &lt;- predict(nlm_freq)\n\nggplot(cbind(Indometh, pred = freq_pred), aes(time, conc)) +\n  facet_wrap(~ Subject) +\n  labs(y = \"Plasma levels (mcg/ml)\", x = \"Time (hours)\") +\n  geom_point(aes(col = Subject), cex = 3) +\n  geom_line(aes(y = pred, col = Subject), linewidth = 1)\n\n\n\n\n\n\n\n\nOur model does a decent job fitting the observed data. But what’s the story beyond standard errors? How do we quantify uncertainty in our model parameters? What’s the likelihood of observing a specific decay rate or baseline level? With frequentist methods, our insights are somewhat limited to point estimates and standard errors. We need a broader view."
  },
  {
    "objectID": "posts/2024-08-05 non-linear-models part 1/index.html#brms-approach",
    "href": "posts/2024-08-05 non-linear-models part 1/index.html#brms-approach",
    "title": "Non-linear models: Pharmacokinetics and Indomethacin",
    "section": "brms approach",
    "text": "brms approach\nTo harness the power of the Bayesian framework, we need to not only define our model but also incorporate prior beliefs about the parameters. Let’s revisit our parameters:\n\n\\(\\alpha\\): Minimum plasma levels of the drug.\n\\(\\beta\\): Baseline plasma levels at time zero.\n\\(\\phi\\): Subject-specific deviation from the population \\(\\beta\\).\n\\(\\lambda\\): The amount of exponential decay.\n\nWe’ll assign prior distributions based on prior knowledge and results from our frequentist model. Here’s the prior setup:\n\nFor \\(\\alpha\\), we’ll use a normal distribution centered around 0.1 mcg/ml with a standard deviation of 0.5 mcg/ml. We’ll truncate this prior at zero, since negative plasma levels aren’t physically meaningful.\nFor \\(\\beta\\), we’ll specify a normal distribution centered around 2.5 mcg/ml with a standard deviation of 3 mcg/ml to avoid overly restricting the parameter space. We’ll also set a lower bound of zero.\nFor \\(\\phi\\), we’ll use a normal prior centered on 0.5 mcg/ml with a moderate standard deviation of 2 mcg/ml to capture variability around baseline levels.\nFor \\(\\lambda\\), we’ll set a weakly informative prior centered around -1 with a standard deviation of 3. This reflects our expectation of a negative decay rate, with the upper bound fixed at zero to prevent increases in plasma levels.\n\nThe priors for our model parameters are:\n\\[\n\\begin{aligned}\n\\alpha &\\sim \\mathcal{N}(0.1, 0.5) \\\\\n\\beta &\\sim \\mathcal{N}(2.5, 3.0) \\\\\n\\phi &\\sim \\mathcal{N}(0.5, 2.0) \\\\\n\\lambda &\\sim \\mathcal{N}(-1.0, 3.0) \\\\\n\\end{aligned}\n\\]\nSo now that we have what we need we can already proceed to fit our bayesian non-linear model:\n\nnlme_brms &lt;- brm(\n  ## Formula\n  formula = bf(conc ~ alpha + (beta + phi) * exp(lambda * time),\n               alpha + beta + lambda ~ 1, phi ~ 1 | Subject,\n               nl = TRUE),\n  data = Indometh,\n  ## Priors\n  prior = prior(normal(0.1, 0.5), nlpar = \"alpha\", lb = 0) +\n    prior(normal(2.5, 3.0), nlpar = \"beta\", lb = 0) +\n    prior(normal(0.5, 2.0), nlpar = \"phi\") +\n    prior(normal(-1.0, 3.0), nlpar = \"lambda\", ub = 0),\n  ## MCMC hyperparameters\n  chains = 5, iter = 4000, \n  warmup = 2000, cores = 5,\n  ## More flexible exploration parameters\n  control = list(adapt_delta = 0.99, \n                 max_treedepth = 50),\n  ## For reproducibility\n  seed = 1234, file = \"nlme_brms.RDS\"\n)\n\nfixef(nlme_brms)\n\n                   Estimate  Est.Error        Q2.5      Q97.5\nalpha_Intercept   0.1346163 0.02173654  0.09162845  0.1768141\nbeta_Intercept    2.6519527 1.44843180  0.24992601  5.7345653\nlambda_Intercept -1.6448947 0.09467393 -1.83556844 -1.4659436\nphi_Intercept     0.2150963 1.44471628 -2.84981889  2.6512578\n\n\nIn this Bayesian model, we get not just point estimates but full distributions for each parameter. This approach allows us to explore the probable range of parameter values and answer probabilistic questions. But first, let’s see how well our Bayesian model fits the observed data:\n\nbmrs_pred &lt;- predict(nlme_brms)\n\nggplot(cbind(Indometh, bmrs_pred), aes(time, conc)) +\n  facet_wrap(~ Subject) +\n  labs(y = \"Plasma levels (mcg/ml)\", x = \"Time (hours)\") +\n  geom_point(aes(col = Subject), cex = 3) +\n  geom_line(aes(y = Estimate, col = Subject), linewidth = 1) +\n  geom_ribbon(aes(ymin = Q2.5, ymax = Q97.5, fill = Subject), alpha = .3)\n\n\n\n\n\n\n\n\nThe Bayesian model’s fitted effects align nicely with the observed data, and the uncertainty around the expected plasma concentrations is well-represented. To explore the range of parameters compatible with our data, we can plot the posterior distributions:\n\nplot(nlme_brms, variable = \"^b_\", regex = TRUE)\n\n\n\n\n\n\n\n\nThese plots reveal a spectrum of parameter values that fit the observed data. For the decay parameter \\(\\lambda\\), we can expect a 78% (\\(1 - \\exp(-1.5)\\)) to 83% (\\(1 - \\exp(-1.8)\\)) decrease in indomethacin plasma concentrations per hour.\nWe can further explore the posterior distributions. For example, transforming the \\(\\lambda\\) parameter into a percentage decay scale:\n\nposterior_dist &lt;- as_draws_df(nlme_brms, variable = \"b_lambda_Intercept\")\nposterior_dist$prob_decay &lt;- (1 - exp(posterior_dist$b_lambda_Intercept))\n\nggplot(posterior_dist, aes(x = prob_decay)) +\n  tidybayes::stat_halfeye(fill = \"lightblue\") +\n  labs(y = \"Density\", x = \"Decay of plasma levels per hour (%)\") +\n  scale_x_continuous(labels = scales::label_percent(), n.breaks = 8)\n\n\n\n\n\n\n\n\nThis flexibility in the Bayesian framework allows us to interpret the decay rate in more intuitive terms, reflecting a range of plausible rates consistent with our data. We can now communicate the percent decay of indomethacin plasma levels in a more accessible manner, considering the variability captured by our model."
  },
  {
    "objectID": "posts/2024-08-05 non-linear-models part 1/index.html#comparing-models",
    "href": "posts/2024-08-05 non-linear-models part 1/index.html#comparing-models",
    "title": "Non-linear models: Pharmacokinetics and Indomethacin",
    "section": "Comparing models",
    "text": "Comparing models\nSo now that we have implemented a linear, non-linear, and a bayesian non-linear model, it’s time to compare the performance across them. We need to consider that these models have unique performance metrics that makes them harder to compare between them. However, we can compute the root-square of the mean of the square residuals (RMSE) to get an intuition of the mean error in the scale of the predictor that the model make when predicting the plasma level for each observation:\n\ndata.frame(\n  lm = performance::performance_rmse(lm_freq),\n  nlme = performance::performance_rmse(nlm_freq),\n  brms = performance::performance_rmse(nlme_brms)\n)\n\n         lm      nlme     brms\n1 0.4417804 0.1080546 0.107791\n\n\nHere, we can observe that both the frequentist and bayesian non-linear models performed much better than the simple linear model. Small RMSE values indicates better performance overall, and in the scale of the predictor, the bayesian model performed marginally better than the frequentist model for a difference of 0.000402 mcg/ml (RMSE(nlme) - RMSE(brms)), considering that the standard deviation of the plasma levels is 0.63 mcg/ml, which can be noted as a insignificant from a practical stand."
  },
  {
    "objectID": "services.html",
    "href": "services.html",
    "title": "Services",
    "section": "",
    "text": "Services"
  },
  {
    "objectID": "services.html#every-problem-is-an-oportunity",
    "href": "services.html#every-problem-is-an-oportunity",
    "title": "Services",
    "section": "Every problem is an oportunity",
    "text": "Every problem is an oportunity\nIf you are having issues with your statistical analyses, research or thesis project, say no more. Here at Bayesically-Speaking we believe in a collaborative and supporting environment, providing consulting services throughout your stats problem.\nWhether you need assistance solving methodological issues, sample size power, interpreting complex models or just in need to wrap your head around statistical concepts, you are in the right place."
  },
  {
    "objectID": "services.html#why-choose-us",
    "href": "services.html#why-choose-us",
    "title": "Services",
    "section": "Why choose us?",
    "text": "Why choose us?\n\n\nExperience\nWe have worked across diverse industries, from healthcare to political sciences.\n\n\nCollaboration\nWe partner with you to understand your unique needs and tailor solutions.\n\n\nResults-Driven\nWe don’t just crunch numbers; we deliver actionable insights.\n\n\nPeople-Centered\nWe are compromised to deliver solutions for non-statisticians."
  },
  {
    "objectID": "services.html#lets-work-together",
    "href": "services.html#lets-work-together",
    "title": "Services",
    "section": "Let’s work together!",
    "text": "Let’s work together!\n Send us an email!"
  },
  {
    "objectID": "posts/2023-05-30 welcome/index.html",
    "href": "posts/2023-05-30 welcome/index.html",
    "title": "Welcome to Bayesically Speaking",
    "section": "",
    "text": "Photo from Jon Tyson at Unsplash."
  },
  {
    "objectID": "posts/2023-05-30 welcome/index.html#the-statistics-toolbox",
    "href": "posts/2023-05-30 welcome/index.html#the-statistics-toolbox",
    "title": "Welcome to Bayesically Speaking",
    "section": "The statistics toolbox",
    "text": "The statistics toolbox\nWithin the statistics toolbox, we have commonly used tests like t-tests, ANOVA, correlations, and regression. These methods have their advantages, as they are relatively easy to use and understand. However, like any other tool, they also have their limitations. For instance, they struggle with scenarios involving variables with asymmetric distributions, non-linear relationships, unbalanced groups, heterogeneous variance, extreme values, or repeated measurements with loss of follow-up.\nTo address these limitations, non-parametric alternatives have been developed. These approaches offer flexibility but make it challenging to extrapolate inferences to new data due to the lack of distributional parameters. Other models, such as neural networks or random forest models, provide assistance when analyzing data with special properties. However, they often sacrifice simplicity and interpretability for increased flexibility and are commonly referred to as “black box” models.\n\n\n\nJust between us, I only put this picture because it looked cool. Photo from Dan Cristian Pădureț at Unsplash.\n\n\nDespite the availability of these alternative methods, there is still a pressing need to incorporate previous knowledge and align with the way human understanding is constructed. As humans, our perception of the world is shaped by experiences and prior beliefs. This is where Bayesian statistics come into play.\nBayesian statistics offer several advantages over classical statistics (also known as “frequentist”). Firstly, they provide a coherent framework for incorporating prior information into our analysis, enabling us to update our beliefs systematically. Additionally, Bayesian statistics allow us to quantify uncertainty through probability distributions, offering a more intuitive and interpretable way to express our findings and the degree of certainty."
  },
  {
    "objectID": "posts/2023-05-30 welcome/index.html#computing-the-posterior",
    "href": "posts/2023-05-30 welcome/index.html#computing-the-posterior",
    "title": "Welcome to Bayesically Speaking",
    "section": "Computing the posterior",
    "text": "Computing the posterior\nTo estimate the posterior probability of getting heads after tossing a coin, we can use the Bayesian framework. Let’s denote the probability of getting heads in a coin toss as \\(P(H)\\).\nAccording to the information provided, we have the prior probability of \\(P(H)\\) estimated from an independent experiment as 10 heads out of 15 tosses. This can be written as a Beta distribution:\n\n\nThis symbol “\\(\\sim\\)” means distributed as\n\\[\nP(H) \\sim Beta(10, 5)\n\\]\nHere, the Beta distribution parameters are (10, 5) since we had 10 heads and 5 tails in the prior experiment.\nNow, a new experiment with the same 15 tosses gives us 2 heads. To update our prior belief, we can use this information to calculate the posterior probability which can be expressed as follow:\n\n\nThis symbol “\\(\\propto\\)” means proportional to\n\\[\nP(H | Data) \\propto P(Data | H) \\times P(H)\n\\]\nWhich is equivalent as saying:\n\\[\nPosterior \\propto Likelihood \\times Prior\n\\]\nTo calculate the posterior probability, we need to normalize the product of the likelihood and prior, which involves integrating over all possible values of H. However, in this case, we can use a shortcut because the prior distribution is conjugate to the binomial distribution, so the posterior distribution will also follow a Beta distribution:\n\n\n\n\n\n\nAbout normalization\n\n\n\n\n\nThe product of both the prior and the likelihood maintains the same shape as the final posterior probability distribution, indicated by the “proportional to” (\\(\\propto\\)) in the previous equation. However, this raw product does not sum up to 1, making it an improper probability density function. To rectify this, the raw product needs to be normalized using integration or simulation in most cases.\n\n\n\n\\[\nP(H | Data) \\sim Beta(10 + 2, 5 + 13)\n\\]\nAfter incorporating the data from the new experiment, the parameters of the Beta distribution become (12, 18) since we had 2 heads and 13 tails in the new experiment, meaning 12 heads and 18 tails in total.\n\n\n\n\n\n\nAbout conjugacy\n\n\n\n\n\nWhen we choose a Beta distribution as our prior belief and gather new data from a coin toss, an intriguing property emerges: the posterior distribution also follows a Beta distribution. This property, known as conjugacy, offers a valuable advantage by simplifying calculations. It acts as a mathematical shortcut that saves time and effort, making the analysis more efficient and streamlined.\n\n\n\nTo calculate the posterior probability of getting heads, we can consider the mode (maximum) of the Beta distribution, which is \\((a - 1) / (a + b - 2)\\):\n\n\\(\\begin{aligned}\nP(H | Data)    &= (12 - 1) / (12 + 18 - 2) \\\\\n               &= 11 / 28 \\\\\n               &\\approx 0.39\n\\end{aligned}\\)\n\nTherefore, the posterior probability of getting heads is approximately 39% when we consider all the available evidence.\n\n\nCode\n# Prior and Likelihood functions\ndata = function(x, to_log = FALSE) dbeta(x, 2, 13, log = to_log)\nprior = function(x, to_log = FALSE) dbeta(x, 10, 5, log = to_log)\n\n# Posterior\nposterior = function(x) {\n  p_fun = function(i) {\n    # Operation is on log-scale merely for computing performance\n    # and minimize rounding errors giving the small nature of\n    # probability density values at each interval.\n    i_log = data(i, to_log = TRUE) + prior(i, to_log = TRUE)\n    # Then transformed back to get probabilities again\n    exp(i_log)\n  }\n  \n  # Then we integrate using base function `integrate`\n  const = integrate(f = p_fun, \n                    lower = 0L,  upper = 1L, \n                    subdivisions = 1e3L,\n                    rel.tol = .Machine$double.eps)$value\n  p_fun(x) / const\n}\n\n## Plotting phase\n\n### Color palette\ncol_pal &lt;- c(Prior = \"#DEEBF7\", \n             Data = \"#3182BD\", \n             Posterior = \"#9ECAE1\")\n### Main plotting code\nggplot() +\n  #### Main probability density functions\n  stat_function(aes(fill = \"Data\"), fun = data, geom = \"density\", alpha = 1/2) +\n  stat_function(aes(fill = \"Prior\"), fun = prior, geom = \"density\", alpha = 1/2) +\n  stat_function(aes(fill = \"Posterior\"), fun = posterior, geom = \"density\", alpha = 1/2) +\n  #### Minor aesthetics tweaks\n  labs(fill = \"\", y = \"Density\", x = \"Probability of getting heads\") +\n  scale_fill_manual(values = col_pal, aesthetics = \"fill\") +\n  scale_x_continuous(labels = scales::label_percent(), \n                     limits = c(0,1)) +\n  scale_y_continuous(expand = c(0,0), limits = c(0, 6.5)) +\n  see::theme_modern() +\n  theme(legend.position = \"top\",\n        legend.spacing.x = unit(3, \"mm\")) +\n  #### Arrows\n  geom_curve(aes(x = .81, y = 4.1, xend = .69232, yend = 3.425), curvature = .4,\n               arrow = arrow(length = unit(1/3, \"cm\"), angle = 20)) +\n  geom_text(aes(x = .9, y = 4.1, label = \"Beta(10,5)\")) +\n  geom_curve(aes(x = .2, y = 5.9, xend = .07693, yend = 5.45), curvature = .4,\n               arrow = arrow(length = unit(1/3, \"cm\"), angle = 20)) +\n  geom_text(aes(x = .29, y = 5.85, label = \"Beta(2,13)\")) +\n  geom_curve(aes(x = .5, y = 5, xend = .3847, yend = 4.4), curvature = .4,\n               arrow = arrow(length = unit(1/3, \"cm\"), angle = 20)) +\n  geom_text(aes(x = .55, y = 5, label = \"≈ 39%\"))\n\n\n\n\n\nGraphical representation of the posterior probability as the combination of both the data and the prior evidence"
  },
  {
    "objectID": "posts/2023-05-30 welcome/index.html#from-past-to-future",
    "href": "posts/2023-05-30 welcome/index.html#from-past-to-future",
    "title": "Welcome to Bayesically Speaking",
    "section": "From past to future",
    "text": "From past to future\nImagine a time not too long ago when Bayesian statistics were not as prevalent as they are today. The computational challenges posed significant hurdles, limiting our ability to fully embrace their potential. But thanks to the rapid advancement of computing power and simulation techniques, the statistical landscape has undergone a revolution. We now find ourselves in an exciting era where complex Bayesian analysis is accessible to all. It’s like having a superpower in the palm of our hands—an empowering time where our statistical prowess can thrive and conquer new frontiers.\nAs passionate self-learners on this thrilling statistical journey, even without a formal statistician’s hat, we can’t help but feel an overwhelming excitement to share the vast potential of these tools for unraveling real-world phenomena. Delving into the world of statistics, especially through the lens of Bayesian inference, opens up a universe of captivating possibilities. By melding prior knowledge with fresh evidence and embracing the enigmatic realm of uncertainty, we can uncover profound insights into health, well-being, and the wondrous phenomena that shape our lives.\nSo, fellow adventurers, let’s ignite our curiosity, embrace our thirst for knowledge, and embark on this exhilarating voyage together. With statistics as our compass, we will navigate the complexities of our reality, expanding our understanding and seizing the extraordinary opportunities that await us.\nGet ready to experience a world that’s more vivid, more nuanced, and more awe-inspiring than ever before. Together, let’s dive into the captivating realm of statistics, fueled by enthusiasm and a passion for discovery."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html",
    "href": "posts/2024-04-14 mcmc part 1/index.html",
    "title": "Markov Chain Monte What?",
    "section": "",
    "text": "Alright, folks, let’s dive into the wild world of statistics and data science! Picture this: you’re knee-deep in data, trying to make sense of the chaos. But here’s the kicker, sometimes the chaos is just too darn complex. With tons of variables flying around, getting a grip on uncertainty can feel like trying to catch smoke with your bare hands.\nPlease, have in your consideration that the kind of problems that we’re dealing with, it’s not solely related to the number of dimensions, it’s mostly related to trying to estimate something that we can’t see in full beforehand. For instance, consider the following banana distribution (shown below). How could we map this simple two dimensional surface without computing it all at once?\n\n\nCode\ndbanana &lt;- function(x) {\n  a = 2;\n  b = 0.2;\n  \n  y = x / a\n  y = (a * b) * (x^2 + a^2)\n}\n\nx &lt;- seq(-6, 6, length.out = 300)\n\ny = dbanana(x)\n\nz &lt;- MASS::kde2d(x, y, n = 100, lims = c(-10, 10, -2.6, 20))\n\nplot_ly(x = z$x, y = z$y, z = sqrt(z$z)) |&gt; \n  add_surface() |&gt; \n  style(hoverinfo = \"none\")\n\n\n\n\n\n\n\n\nYou know when you hit a roadblock in your calculations, and you’re like, “Can’t we just crunch the numbers for every single value?” Well, let’s break it down. Picture a grid with \\(N\\) points for \\(D\\) dimensions. Now, brace yourself, ’cause the math needed is like \\(N\\) raised to the power of \\(D\\).\nSo, let’s say you wanna estimate 100 points (to get a decent estimation of the shape) for each of 100 dimensions. That’s like slamming your head against ten to the power of 200 computations… that’s a hell of a lot of computations!\nSure, in la-la land, you could approximate every single number with some degree of approximation. But let’s get real here, even if you had all the time in the world, you’d still be chipping away at those calculations until the sun swallowed the Earth, especially with continuous cases and tons of dimensions that are somewhat correlated (which in reality, tends to be the case).\nThis headache we’re dealing with? It’s what we “affectionately” call — emphasis on double quotes — the curse of dimensionality. It’s like trying to squeeze a square peg into a round hole… it ain’t gonna happen without a supersized hammer!\n\n\nCode\ncurse_dimensionality &lt;- data.frame(dimensions = factor((1:10)^2),\n                                   calculations = 100^((1:10)^2))\n\nggplot(curse_dimensionality, aes(dimensions, calculations)) +\n  geom_col(fill = ggsci::pal_jama()(1)) +\n  scale_y_continuous(transform = \"log10\", n.breaks = 9,\n                     labels = scales::label_log(), expand = c(0,0,.1,0)) +\n  labs(y = \"Computations (log-scale)\", x = \"Dimensions (Variables)\",\n       title = \"Computations needed to compute a grid of 100 points\",\n       subtitle = \"As a function of dimensions/variables involved\") +\n  theme_classic(base_size = 20)\n\n\n\n\n\nIllustration of computations needed (in log-scale) for 100 points as a function of dimensions considered.\n\n\n\n\n\n\n\n\n\n\nExplaining the curse of dimensionality further\n\n\n\n\n\nImagine you’re trying to create a grid to map out the probability space for a set of variables. As the number of dimensions increases, the number of grid points needed to adequately represent the space explodes exponentially. This means that even with the most powerful computers, it becomes practically impossible to compute all the probabilities accurately.\n\n\n\n\n\n\nNow, if we can’t crack the problem analytically (which, let’s face it, is the case most of the time), we gotta get creative. Lucky for us, there’s a bunch of algorithms that can lend a hand by sampling this high-dimensional parameter space. Enter the Markov Chain Monte Carlo (MCMC) family of algorithms.\nBut hold up — Markov Chain Monte What? Yeah, it’s a mouthful, but bear with me. You’re probably wondering how this fancy-schmancy term is connected to exploring high-dimensional probability spaces. Well, I’ll let you in on the secret sauce behind these concepts and why they’re the go-to tools in top-notch probabilistic software like Stan.\nBut before we get into the nitty-gritty of MCMC, let’s take a detour and talk about Markov Chains, because they’re like the OGs of this whole MCMC gang."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#just-put-a-darn-grid-to-it",
    "href": "posts/2024-04-14 mcmc part 1/index.html#just-put-a-darn-grid-to-it",
    "title": "Markov Chain Monte What?",
    "section": "",
    "text": "You know when you hit a roadblock in your calculations, and you’re like, “Can’t we just crunch the numbers for every single value?” Well, let’s break it down. Picture a grid with \\(N\\) points for \\(D\\) dimensions. Now, brace yourself, ’cause the math needed is like \\(N\\) raised to the power of \\(D\\).\nSo, let’s say you wanna estimate 100 points (to get a decent estimation of the shape) for each of 100 dimensions. That’s like slamming your head against ten to the power of 200 computations… that’s a hell of a lot of computations!\nSure, in la-la land, you could approximate every single number with some degree of approximation. But let’s get real here, even if you had all the time in the world, you’d still be chipping away at those calculations until the sun swallowed the Earth, especially with continuous cases and tons of dimensions that are somewhat correlated (which in reality, tends to be the case).\nThis headache we’re dealing with? It’s what we “affectionately” call — emphasis on double quotes — the curse of dimensionality. It’s like trying to squeeze a square peg into a round hole… it ain’t gonna happen without a supersized hammer!\n\n\nCode\ncurse_dimensionality &lt;- data.frame(dimensions = factor((1:10)^2),\n                                   calculations = 100^((1:10)^2))\n\nggplot(curse_dimensionality, aes(dimensions, calculations)) +\n  geom_col(fill = ggsci::pal_jama()(1)) +\n  scale_y_continuous(transform = \"log10\", n.breaks = 9,\n                     labels = scales::label_log(), expand = c(0,0,.1,0)) +\n  labs(y = \"Computations (log-scale)\", x = \"Dimensions (Variables)\",\n       title = \"Computations needed to compute a grid of 100 points\",\n       subtitle = \"As a function of dimensions/variables involved\") +\n  theme_classic(base_size = 20)\n\n\n\n\n\nIllustration of computations needed (in log-scale) for 100 points as a function of dimensions considered.\n\n\n\n\n\n\n\n\n\n\nExplaining the curse of dimensionality further\n\n\n\n\n\nImagine you’re trying to create a grid to map out the probability space for a set of variables. As the number of dimensions increases, the number of grid points needed to adequately represent the space explodes exponentially. This means that even with the most powerful computers, it becomes practically impossible to compute all the probabilities accurately."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#sampling-the-unknown-markov-chain-monte-carlo",
    "href": "posts/2024-04-14 mcmc part 1/index.html#sampling-the-unknown-markov-chain-monte-carlo",
    "title": "Markov Chain Monte What?",
    "section": "",
    "text": "Now, if we can’t crack the problem analytically (which, let’s face it, is the case most of the time), we gotta get creative. Lucky for us, there’s a bunch of algorithms that can lend a hand by sampling this high-dimensional parameter space. Enter the Markov Chain Monte Carlo (MCMC) family of algorithms.\nBut hold up — Markov Chain Monte What? Yeah, it’s a mouthful, but bear with me. You’re probably wondering how this fancy-schmancy term is connected to exploring high-dimensional probability spaces. Well, I’ll let you in on the secret sauce behind these concepts and why they’re the go-to tools in top-notch probabilistic software like Stan.\nBut before we get into the nitty-gritty of MCMC, let’s take a detour and talk about Markov Chains, because they’re like the OGs of this whole MCMC gang."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#converging-to-an-answer",
    "href": "posts/2024-04-14 mcmc part 1/index.html#converging-to-an-answer",
    "title": "Markov Chain Monte What?",
    "section": "Converging to an answer",
    "text": "Converging to an answer\nNow, let’s imagine letting time run. After a year passes, if we observe how the weather behaves, we’ll notice that the relative frequencies of each state tend to converge to a single number.\nNow, fast forward a year. If we keep an eye on the weather every day, we’ll notice something interesting: the relative frequencies of rainy and sunny days start to settle into a rhythm. This steady state is what we call a stationary distribution. It’s like the true probability of what the weather’s gonna be like in the long run, taking into account all the different scenarios.\n\n\nCode\nsimulate_weather &lt;- function(total_time) {\n  \n  weather &lt;- vector(\"character\", total_time) # Create slots for each day\n  day &lt;- 1 # First day\n  weather[day] &lt;- sample(c(\"Rainy\", \"Sunny\"), size = 1) # Weather for first day\n  \n  while (day &lt; total_time) {\n    day &lt;- day + 1 # Add one more day\n    if (weather[day] == \"Rainy\") {\n      weather[day] &lt;- sample(c(\"Rainy\", \"Sunny\"), size = 1, prob = c(.6, .4))\n    } else {\n      weather[day] &lt;- sample(c(\"Rainy\", \"Sunny\"), size = 1, prob = c(.3, .7))\n    }\n  }\n  \n  return(weather)\n}\n\nsim_time &lt;- 365*1\nweather &lt;- simulate_weather(total_time = sim_time)\n\nweather_data &lt;- data.frame(\n  prop = c(cumsum(weather == \"Rainy\") / seq_len(sim_time), cumsum(weather == \"Sunny\") / seq_len(sim_time)),\n  time = c(seq_len(sim_time), seq_len(sim_time)),\n  weather = c(rep(\"Rainy\", times = sim_time), rep(\"Sunny\", times = sim_time))\n)\n\nggplot(weather_data, aes(time, prop, fill = weather)) +\n  geom_area() +\n  scale_y_continuous(labels = scales::label_percent(), n.breaks = 6,\n                     name = \"Proportion of each weather\", expand = c(0,0)) +\n  scale_x_continuous(name = \"Days\", n.breaks = 10, expand = c(0,0)) +\n  scale_fill_brewer(type = \"qual\", palette = 3) +\n  labs(fill = \"Weather\", title = \"Convergence to stationary distribution\",\n       subtitle = \"Based on cumulative proportion of each Sunny or Rainy days\") +\n  theme_classic(base_size = 20)\n\n\n\n\n\nCumulative mean proportion of sunny/rainy days across 365 days. Right pass the 100 days, the proportion of rainy/sunny days tends to display a stable trend when we averaged the previous days. This is known as stationary distribution.\n\n\n\n\nThis heuristic allows us to naturally converge to an answer without needing to solve it analytically, which tends to be useful for really complex and high-dimensional problems.\nSure, we could’ve crunched the numbers ourselves to figure out these probabilities. But why bother with all that math when we can let time do its thing and naturally converge to the same answer? Especially when we’re dealing with complex problems that could have given even Einstein himself a headache.\n\n\n\n\n\n\nExplaining the convergence process further\n\n\n\n\n\nThe idea of convergence to a stationary distribution can be likened to taking a random walk through the space of possible outcomes. Over time, the relative frequencies of each outcome stabilize, giving us a reliable estimate of the true probabilities.\n\n\n\nAs we’ve seen, sometimes it becomes impractical to solve analytically or even approximate the posterior distribution using a grid, given the number of calculations needed to even get a decent approximation of the posterior.\nHowever, we’ve also seen that Markov Chains might offer us a way to compute complex conditional probabilities and, if we let them run long enough, they will eventually converge to the stationary distribution, which could resemble the posterior distribution itself. So, all things considered, when does the Monte Carlo part come in?"
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#what-is-mcmc-actually-doing",
    "href": "posts/2024-04-14 mcmc part 1/index.html#what-is-mcmc-actually-doing",
    "title": "Markov Chain Monte What?",
    "section": "What is MCMC actually doing?",
    "text": "What is MCMC actually doing?\nIn essence, MCMC is an algorithm that generates random samples from a proposal distribution. These samples are accepted or rejected based on how much more likely the proposed sample is compared to the previous accepted sample.\nIn this way, the proposed samples are accepted in the same proportion as the actual probability in the target distribution, accepting more samples that are more likely and fewer samples that are less likely.\nThe fascinating nature of this heuristic is that it works to approximate complex distributions without needing to know much about the shape of the final distribution.\nSo, think of it as trekking through this complex landscape, taking random steps (the Monte Carlo part) but guided by the likelihood of each move, given where you currently stand (the Markov Chain part). It’s a meticulous journey, but one that ultimately leads us to a better understanding of these elusive distributions.\nFor instance, consider that we have a distribution (shown below) that we can’t to compute, because it would take too long to integrate the whole function. This will be our target distribution, from which we can only compute the density of one value at a time.\n\n\n\n\n\n\nAbout the target distribution\n\n\n\n\n\nIn practice, we would derive the target distribution from the data and prior information, this enable us to estimate the density in a point-wise manner, without the need to estimate the whole PDF all at once. But for the sake of demonstration we will the use the Gamma probability density function.\nHowever, please consider that you can’t use some family distribution to describe perfectly any probability density, sometimes it can be a mixture of distributions, truncation, censoring. All comes down to the underlying process that generates the data that we are trying to mimic.\n\n\n\n\n\nCode\n# Target distribution that we in practice would derive from\n# the data.\ntarget_dist &lt;- function(i) dgamma(i, shape = 2, scale = 1)\n\nggplot() +\n  stat_function(fun = target_dist,\n                xlim = c(0, 11), geom = \"area\", \n                fill = \"#374E55FF\") +\n  scale_y_continuous(breaks = NULL, name = \"Density\", expand = c(0,0)) +\n  scale_x_continuous(name = \"Some scale\", expand = c(0,0)) +\n  theme_classic(base_size = 20)\n\n\n\n\n\nThis is a Gamma distribution with shape of 2 and scale of 1. We will try to estimate it.\n\n\n\n\nNext thing to do is to specify a proposal distribution, from which we’ll generate proposals for the next step. To this end we’ll be using a Normal density function with \\(\\mu\\) = 0 and \\(\\sigma\\) = 1.\n\n# This is a function that will generate proposals for the next step.\nproprosal &lt;- function() rnorm(1, mean = 0, sd = 1)\n\nAnd set some algorithm parameters that are necessary for our MCMC to run:\n\n## Algorithm parameters ----\n\ntotal_steps &lt;- 1000 # Total number of steps\nstep &lt;- 1 # We start at step 1\nvalue &lt;- 10 # set a initial starting value\n\nFinally, we run our algorithm as explained in previous sections. Try to follow the code to get an intuition of what is doing.\n\n## Algorithm ----\n\nset.seed(1234) # Seed for reproducibility\nwhile(step &lt; total_steps) {\n  # Increase for next step\n  step &lt;- step + 1\n  \n  ## 1. Propose a new value ----\n  \n  # Proposal of the next step is ...\n  value[step] &lt;- \n    # the previous step plus...\n    value[step - 1L] + \n    # a change in a random direction (based on the \n    # proposal distribution)\n    proprosal() \n  \n  ## 2. We see if the new value is more or less likely ----\n  \n  # How likely (in the target distribution)\n  likelihood &lt;- \n    # is the proposed value compared to the previous step\n    target_dist(value[step]) / target_dist(value[step - 1L]) \n  \n  ## 3. Based on its likelihood, we accept or reject it ----\n  \n  # If the proposal value is less likely, we accept it only \n  # to the likelihood of the proposed value\n  if (likelihood &lt; runif(1)) \n    value[step] &lt;- value[step - 1L]\n  \n  # Then we repeat for the next step\n}\n\nFinally, let’s explore how well our algorithm converge to the target distribution.\n\n\nCode\nmcmc &lt;- data.frame(\n  step = seq_len(step),\n  value = value\n)\n\nggplot(mcmc, aes(x = step, y = value)) +\n  geom_line(col = \"#374E55FF\") +\n  ggside::geom_ysidehistogram(aes(x = -after_stat(count)), fill = \"#374E55FF\", binwidth = .3) +\n  ggside::geom_ysidedensity(aes(x = -after_stat(count)*.35), col = \"#374E55FF\") +\n  ggside::scale_ysidex_continuous(expand = c(0,0,0,.1), breaks = NULL) +\n  scale_x_continuous(expand = c(0,0), name = \"Step\") +\n  scale_y_continuous(name = NULL, position = \"right\") +\n  labs(title = \"Trace of MCMC values to target distribution\",\n       subtitle = \"Evolution of values at each step\") +\n  theme_classic(base_size = 20) +\n  ggside::ggside(y.pos = \"left\") +\n  theme(ggside.panel.scale = .4)\n\n\n\n\n\nTraceplot of convergence of MCMC for 1000 steps. With increasing steps we see an increasing resemblance to the target distribution.\n\n\n\n\nAnother thing that we care is to see how well our MCMC is performing. After all, if not, then what would be the point of using it in first place? To check this, we’ll compare the expectation (\\(E(X)\\)) of the target distribution against the posterior derived from our MCMC.\nFor this, we have to consider that the expectation, \\(E(X)\\), of any Gamma distribution is equal to the shape parameter (\\(\\alpha\\)) times by the scale parameter (\\(\\sigma\\)). We could express the aforementioned the following.\n\n\\(\\begin{aligned}\n  E(X) &= \\alpha \\sigma \\\\\n  \\text{with}~X &\\sim \\text{Gamma}(\\alpha, \\sigma)\n\\end{aligned}\\)\n\n\n\nCode\nggplot(mcmc, aes(x = step, y = cumsum(value)/step)) +\n  geom_line(col = \"#374E55FF\") +\n  scale_x_continuous(expand = c(0,.1), name = \"Steps (log-scale)\", \n                     transform = \"log10\", labels = scales::label_log()) +\n  scale_y_continuous(name = NULL, expand = c(0, 1)) +\n  labs(title = \"Convergence to location parameter\",\n       subtitle = \"Cumulative mean across steps\") +\n  geom_hline(aes(yintercept = 2), col = \"darkred\") +\n  geom_hline(aes(yintercept = mean(value)), lty = 2) +\n  annotate(x = 1.5, xend = 1.1, y = 7.5, yend = 9.5, geom = \"curve\", curvature = -.2,\n           arrow = arrow(length = unit(.1, \"in\"), type = \"closed\")) +\n  annotate(x = 2, y = 6.8,  label = \"Initial value\", size = 5, geom = \"text\") +\n  annotate(x = (10^2.5), xend = (10^2.6), y = 5, yend = 2.5, geom = \"curve\", curvature = .2,\n           arrow = arrow(length = unit(.1, \"in\"), type = \"closed\")) +\n  annotate(x = (10^2.5), y = 5.8,  label = \"Convergence\", size = 5, geom = \"text\") +\n  theme_classic(base_size = 20)\n\n\n\n\n\nCumulative mean of the posterior distributions across steps, compared to the empirical mean of the target distribution. Here the dark red line represents the empirical location parameter and the dashed line the one estimated using MCMC."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#gibbs-sampling-a-buffet-adventure",
    "href": "posts/2024-04-14 mcmc part 1/index.html#gibbs-sampling-a-buffet-adventure",
    "title": "Markov Chain Monte What?",
    "section": "Gibbs Sampling: A Buffet Adventure",
    "text": "Gibbs Sampling: A Buffet Adventure\nImagine you’re at a buffet with stations offering various cuisines — Italian, Chinese, Mexican — you name it. You’re on a mission to create a plate with a bit of everything, but here’s the catch: you can only visit one station at a time. Here’s how you tackle it:\n\nHit up a station and randomly pick a dish.\nMove on to the next station and repeat the process.\nKeep going until you’ve got a plateful of diverse flavors.\n\nGibbs sampling works kind of like this buffet adventure. You take turns sampling from conditional distributions, just like you visit each station for a dish. Each time, you focus on one variable, updating its value while keeping the others constant. It’s like building your plate by sampling from each cuisine until you’ve got the perfect mix."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#hamiltonian-monte-carlo-charting-your-hiking-path",
    "href": "posts/2024-04-14 mcmc part 1/index.html#hamiltonian-monte-carlo-charting-your-hiking-path",
    "title": "Markov Chain Monte What?",
    "section": "Hamiltonian Monte Carlo: Charting Your Hiking Path",
    "text": "Hamiltonian Monte Carlo: Charting Your Hiking Path\nPicture yourself hiking up a rugged mountain with rocky trails and valleys. Your goal? Reach the summit without breaking a sweat — or falling off a cliff. So, you whip out your map and binoculars to plan your route:\n\nStudy the map to plot a path with minimal uphill battles and maximum flat stretches.\nUse the binoculars to scout ahead and avoid obstacles along the way.\nAdjust your route as you go, smoothly navigating the terrain like a seasoned pro.\n\nHamiltonian Monte Carlo (HMC) is a bit like this hiking adventure. It simulates a particle moving through a high-dimensional space, using gradient info to find the smoothest path. Instead of blindly wandering, HMC leverages the curvature of the target distribution to explore efficiently. It’s like hiking with a GPS that guides you around the rough spots and straight to the summit."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#strengths-weaknesses-and-real-world-applications",
    "href": "posts/2024-04-14 mcmc part 1/index.html#strengths-weaknesses-and-real-world-applications",
    "title": "Markov Chain Monte What?",
    "section": "Strengths, Weaknesses, and Real-World Applications",
    "text": "Strengths, Weaknesses, and Real-World Applications\nNow that you’ve dipped your toes into the MCMC pool, it’s time to talk turkey — well, sampling. Each MCMC method has its perks and quirks, and knowing them is half the battle.\nGibbs sampling is the laid-back surfer dude of the group — simple, chill, and great for models with structured dependencies. But throw in some highly correlated variables, and it starts to wobble like a rookie on a surfboard.\nMeanwhile, HMC is the sleek Ferrari — efficient, powerful, and perfect for tackling complex models head-on. Just don’t forget to fine-tune those parameters, or you might end up spinning out on a sharp curve."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#key-differences",
    "href": "posts/2024-04-14 mcmc part 1/index.html#key-differences",
    "title": "Markov Chain Monte What?",
    "section": "Key Differences",
    "text": "Key Differences\n\nSampling Approach\n\nMetropolis-Hastings: Takes random walks to generate samples, with acceptance based on a ratio of target distribution probabilities.\nGibbs Sampling: Updates variables one by one based on conditional distributions, like a tag team wrestling match.\nHamiltonian Monte Carlo: Glides through high-dimensional space using deterministic trajectories guided by Hamiltonian dynamics, like a graceful dancer in a crowded room.\n\n\n\nEfficiency and Exploration\n\nMetropolis-Hastings: Easy to implement but might struggle to explore efficiently, especially in high-dimensional spaces.\nGibbs Sampling: Perfect for structured models but may stumble with highly correlated variables.\nHamiltonian Monte Carlo: Efficiently navigates high-dimensional spaces, leading to faster convergence and smoother mixing.\n\n\n\nAcceptance Criterion\n\nMetropolis-Hastings: Decides whether to accept or reject proposals based on a ratio of target distribution probabilities.\nGibbs Sampling: Skips the acceptance drama and generates samples directly from conditional distributions.\nHamiltonian Monte Carlo: Judges proposals based on the joint energy of position and momentum variables, like a strict dance instructor.\n\n\n\nParameter Tuning and Complexity\n\nMetropolis-Hastings: Requires tweaking the proposal distribution but keeps it simple.\nGibbs Sampling: A breeze to implement, but watch out for those conditional distributions — they can be sneaky.\nHamiltonian Monte Carlo: Needs tuning of parameters like step size and trajectory length, and the implementation might get a bit hairy with momentum variables and gradient computation."
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#mcmc-in-action",
    "href": "posts/2024-04-14 mcmc part 1/index.html#mcmc-in-action",
    "title": "Markov Chain Monte What?",
    "section": "MCMC in action",
    "text": "MCMC in action\nIn the following, you can see an interactive animation of different MCMC algorithms (MH, Gibbs and HMC) and how they work to uncover distributions in two dimensions. The code for this animation is borrowed from Chi Feng’s github. You can find the original repository with corresponding code here: https://github.com/chi-feng/mcmc-demo"
  },
  {
    "objectID": "posts/2024-04-14 mcmc part 1/index.html#implementing-mcmc-algorithms-in-practice",
    "href": "posts/2024-04-14 mcmc part 1/index.html#implementing-mcmc-algorithms-in-practice",
    "title": "Markov Chain Monte What?",
    "section": "Implementing MCMC Algorithms in Practice",
    "text": "Implementing MCMC Algorithms in Practice\nAlright, theory’s cool and all, but let’s get down to brass tacks. When you’re rolling up your sleeves to implement MCMC algorithms, it’s like picking the right tool for the job. Simple models? Metropolis-Hastings or Gibbs sampling has your back. But when you’re wrangling with the big boys — those complex models — that’s when you call in Hamiltonian Monte Carlo. It’s like upgrading from a rusty old wrench to a shiny new power tool. And don’t forget about tuning those parameters — it’s like fine-tuning your car for a smooth ride.\nBeyond all the technical jargon, successful Bayesian inference is part gut feeling, part detective work. Picking the right priors is like seasoning a dish — you want just the right flavor without overpowering everything else. And tuning those parameters? It’s like fine-tuning your favorite instrument to make sure the music hits all the right notes."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Bayesically Speaking\n\n\nPriors & Coffee\n\n\n\n\n\n\n\nWhat is this?\nIf you are curious about how to use data and probability to understand and visualize real world problems, you have come to the right place.\n About  Related work\n\n\n\n\n\n\nLatest posts\n See all posts\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nNon-linear models: Pharmacokinetics and Indomethacin\n\n\n15 min\n\n\nHere we dive in the process of making a non-linear model to predict the decay of plasma levels of an anti-inflammatory drug, and compare frequentist and bayesian methods.\n\n\n\nAug 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Good, The Bad, and Hamiltonian Monte Carlo\n\n\n30 min\n\n\nFollowing the footsteps of the previous post, here we delve ourselves into the mud of hamiltonian mechanics and how its dynamics can help us to explore parameter space more…\n\n\n\nMay 15, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarkov Chain Monte What?\n\n\n23 min\n\n\nIn this post we will delve into the main idea behind Markov Chain Monte Carlo (MCMC for short) and why it is useful within the bayesian inference framework.\n\n\n\nApr 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome to Bayesically Speaking\n\n\n12 min\n\n\nHi everyone! This is the first post of Bayesically Speaking, so get your seatbelt on and get ready to join me on this ride!\n\n\n\nJun 10, 2023\n\n\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\nNeed asistance with your analyses?\nWhether you need assistance performing complex statistical analysis for your project or simply need help wrapping your head around some statistics concepts, our team is ready to assist you.\n Check our services  Contact us"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Portfolio",
    "section": "",
    "text": "Portfolio"
  },
  {
    "objectID": "cv.html#footnotes",
    "href": "cv.html#footnotes",
    "title": "Portfolio",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nChilean Austral Molecular Integrative Neurophysiology by its acronym in Spanish.↩︎"
  }
]