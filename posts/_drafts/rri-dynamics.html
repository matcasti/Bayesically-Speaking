<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Untitled</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="rri-dynamics_files/libs/clipboard/clipboard.min.js"></script>
<script src="rri-dynamics_files/libs/quarto-html/quarto.js"></script>
<script src="rri-dynamics_files/libs/quarto-html/popper.min.js"></script>
<script src="rri-dynamics_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="rri-dynamics_files/libs/quarto-html/anchor.min.js"></script>
<link href="rri-dynamics_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="rri-dynamics_files/libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="rri-dynamics_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="rri-dynamics_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="rri-dynamics_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Untitled</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="adapting-the-model-rri-dynamics-with-the-actual-double-logistic-function-expanded-universe-edition" class="level1">
<h1>Adapting the Model: RRi Dynamics with the Actual Double Logistic Function (Expanded Universe Edition!)</h1>
<p>Alright, alright, mea culpa acknowledged! We previously wandered off the reservation with a generic model, but thanks to your eagle eyes, we’re back on track with the specific Castillo-Aguilar et al.&nbsp;(2025) equation. Consider the imposter banished! Our noble quest remains: to model the often-dramatic, sometimes-infuriating rollercoaster ride of R-R intervals (RRi), that crucial time gap between heartbeats. Why RRi? Because sometimes looking at the time between beats, rather than the rate itself (remember, <span class="math inline">\(HR \approx 60 / RRi\)</span>), gives a clearer view of the physiological drama unfolding, especially during events like exercise where your heart seems determined to beat its way out of your chest, followed by the slow, gasping crawl back to normalcy. This specific model is like a custom-built rollercoaster track, designed precisely to capture that characteristic plunge (RRi shortens) and the subsequent, hopefully proportional, climb back up (RRi lengthens).</p>
</section>
<section id="the-real-double-logistic-model-untangling-the-equation-beast-take-2---directors-cut" class="level1">
<h1>The Real Double Logistic Model: Untangling the Equation Beast (Take 2 - Director’s Cut)</h1>
<p>So, let’s once again lay our eyes upon the authentic artifact, the mathematical Rosetta Stone for this particular physiological phenomenon:</p>
<p><span class="math display">\[
RRi(t) = \alpha + \frac{\beta}{1 + \exp(\lambda(t - \tau))} + \frac{-c\beta}{1 + \exp(\phi(t - \tau - \delta))}
\]</span></p>
<p>It might look like alphabet soup seasoned with Greek letters, but fear not! It’s just two S-shaped curves (sigmoids, technically logistic functions) bolted together. Think of it as describing two distinct phases of change. Why two? Because physiological responses are rarely simple up-or-down affairs. Often, there’s an initial reaction followed by a recovery or adaptation phase moving in a different direction or at a different speed. This equation gives us the flexibility to model such biphasic shenanigans. Let’s re-acquaint ourselves with the parameters, the knobs and dials controlling our RRi rollercoaster:</p>
<p><span class="math inline">\(RRi(t)\)</span>: The variable we’re chasing, the R-R interval (often in milliseconds) at any given time (<span class="math inline">\(t\)</span>). This is the output, the predicted position on our rollercoaster track at time <span class="math inline">\(t\)</span>.</p>
<ul>
<li><span class="math inline">\(\alpha\)</span> (alpha): Our starting altitude, the baseline RRi. This is where your heart chills out before the stimulus (exercise, stress, that third cup of coffee) hits the system. It’s the physiological ‘ground level’ from which all changes are measured. Think of it as the stable RRi value during rest or before the experiment begins.</li>
<li><span class="math inline">\(\beta\)</span> (beta): The amplitude, or total vertical distance covered, by the first phase of the ride, typically the initial stress response. For exercise, <span class="math inline">\(\beta\)</span> is usually negative because RRi gets shorter (heart rate increases). Its magnitude tells us how much the RRi changes in this first phase. It’s the height of the first big drop on our rollercoaster.</li>
<li><span class="math inline">\(\lambda\)</span> (lambda): The ‘steepness’ or rate parameter for that first phase. It controls how quickly the RRi changes around the midpoint (<span class="math inline">\(\tau\)</span>) of this initial transition. A larger <span class="math inline">\(\lambda\)</span> value means a faster, more abrupt change, like going over a sharp cliff edge. A smaller <span class="math inline">\(\lambda\)</span> means a more gradual slope. Its units are typically inverse time (like 1/seconds), reflecting its nature as a rate constant.</li>
<li><span class="math inline">\(\tau\)</span> (tau): The temporal midpoint of the first phase. It’s the exact time point (t = <span class="math inline">\(\tau\)</span>) where the rate of change during the initial phase is maximal (the steepest point on the first S-curve). It tells us when the first transition is centered.</li>
<li><span class="math inline">\(-c\beta\)</span>: The amplitude of the second phase, representing the recovery. Here’s where the model gets clever. Instead of being independent, this amplitude is proportional to the first amplitude (<span class="math inline">\(\beta\)</span>) via the factor -c.&nbsp;The constant c is a dimensionless proportionality factor (often between 0 and 1, representing the fraction of recovery). If c=1, the recovery amplitude perfectly mirrors the drop amplitude (in the opposite direction). If c=0.8, the recovery only makes up 80% of the initial drop. The negative sign cleverly ensures that if <span class="math inline">\(\beta\)</span> caused a drop (negative <span class="math inline">\(\beta\)</span>), then <span class="math inline">\(-c\beta\)</span> causes a rise (positive value), assuming c itself is positive. This elegantly links the size of the recovery to the size of the initial stress response, a common physiological observation.</li>
<li><span class="math inline">\(\phi\)</span> (phi): The steepness parameter for the second (recovery) phase. Just like <span class="math inline">\(\lambda\)</span>, it controls how quickly the RRi changes during recovery, centered around the recovery’s own midpoint (t = <span class="math inline">\(\tau + \delta\)</span>). A larger <span class="math inline">\(\phi\)</span> means a faster recovery. It also has units of inverse time.</li>
<li><span class="math inline">\(\delta\)</span> (delta): The time delay parameter. It represents the time lag between the midpoint of the initial drop (<span class="math inline">\(\tau\)</span>) and the midpoint of the recovery phase. The recovery phase is centered at time t = <span class="math inline">\(\tau + \delta\)</span>. This parameter explicitly links the timing of the recovery phase to the timing of the initial response, acknowledging that recovery doesn’t usually start instantly but after some delay.</li>
</ul>
<p>This specific structure, with its linked parameters (<span class="math inline">\(-c\beta\)</span> and <span class="math inline">\(\tau + \delta\)</span>), is what makes the Castillo-Aguilar model distinct from a generic double logistic function. It bakes in assumptions about how the recovery relates to the initial perturbation, making it potentially more physiologically interpretable (or at least, more specific in its assumptions).</p>
</section>
<section id="implementing-the-specific-double-logistic-function-in-r" class="level1">
<h1>Implementing the Specific Double Logistic Function in R</h1>
<p>Okay, enough theory, let’s talk code. Translating this equation, with its specific parameters and structure, into R requires careful mapping. We need to ensure our R function arguments correspond correctly to <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\lambda\)</span>, <span class="math inline">\(\tau\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\delta\)</span> and that the mathematical operations, especially those tricky exponents, are implemented exactly as written in the equation. Note that we use c_param in R for the proportionality constant c to avoid clashing with R’s built-in <code>c()</code> function (which combines values into a vector, a classic R naming collision trap!).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Double Logistic Function for RRi(t)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Based *specifically* on the Castillo-Aguilar et al. (2025) equation provided.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># This function calculates the RRi value at a specific time 't'.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>rri_double_logistic <span class="ot">&lt;-</span> <span class="cf">function</span>(t, alpha, beta, lambda, tau, c_param, phi, delta) {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># t: Time point ($t$)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># alpha: Baseline RRi value (parameter $\alpha$)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># beta: Amplitude of the first component (parameter $\beta$)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lambda: Steepness of the first component (parameter $\lambda$)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># tau: Inflection time of the first component (parameter $\tau$)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># c_param: Proportionality constant for recovery amplitude (parameter $c$)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># phi: Steepness of the second component (parameter $\phi$)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># delta: Delay for the second component's inflection time (parameter $\delta$)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Calculate the first logistic component (Exercise-induced Drop)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Corresponds to: $\beta / (1 + \exp(\lambda(t - \tau)))$</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  component1 <span class="ot">&lt;-</span> beta <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(lambda <span class="sc">*</span> (t <span class="sc">-</span> tau)))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Calculate the second logistic component (Proportional Recovery)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Corresponds to: $(-c\beta) / (1 + \exp(\phi(t - \tau - \delta)))$</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Amplitude is -c_param * beta</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Inflection time is tau + delta</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  component2 <span class="ot">&lt;-</span> (<span class="sc">-</span>c_param <span class="sc">*</span> beta) <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="fu">exp</span>(phi <span class="sc">*</span> (t <span class="sc">-</span> tau <span class="sc">-</span> delta)))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Calculate the final RRi value: $\alpha + component1 + component2$</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  rri_t <span class="ot">&lt;-</span> alpha <span class="sc">+</span> component1 <span class="sc">+</span> component2</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(rri_t)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage (replace with plausible parameters based on the paper's context)</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>time_point <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">20</span>, <span class="fl">0.1</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>baseline_alpha <span class="ot">&lt;-</span> <span class="dv">800</span> <span class="co"># ms ($\alpha$)</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>drop_amplitude_beta <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">300</span> <span class="co"># ms ($\beta$, negative for drop)</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>drop_steepness_lambda <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">1.5</span> <span class="co"># ($\lambda$)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>drop_time_tau <span class="ot">&lt;-</span> <span class="dv">5</span>  <span class="co"># s ($\tau$)</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>recovery_factor_c <span class="ot">&lt;-</span> <span class="fl">0.9</span> <span class="co"># ($c$, e.g., 90% recovery)</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>recovery_steepness_phi <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">0.5</span> <span class="co"># ($\phi$)</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>recovery_delay_delta <span class="ot">&lt;-</span> <span class="dv">5</span> <span class="co"># s ($\delta$)</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>predicted_rri <span class="ot">&lt;-</span> <span class="fu">rri_double_logistic</span>(<span class="at">t =</span> time_point,</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">alpha =</span> baseline_alpha,</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">beta =</span> drop_amplitude_beta,</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">lambda =</span> drop_steepness_lambda,</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">tau =</span> drop_time_tau,</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">c_param =</span> recovery_factor_c,</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">phi =</span> recovery_steepness_phi,</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">delta =</span> recovery_delay_delta)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(time_point, predicted_rri, <span class="at">type =</span> <span class="st">"l"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="rri-dynamics_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>There we go. Our R function now faithfully replicates the Castillo-Aguilar equation. But hold your horses! Our trusty numerical integrator, the leapfrog algorithm (or any similar method like Runge-Kutta), doesn’t operate on the RRi(t) value directly. It’s like a car’s engine, it needs fuel rate, not just the current position. It needs to know the instantaneous rate of change, the velocity of our RRi value. In mathematical terms, it demands the derivative: d(RRi)/dt. So, back to the glorious, sometimes painful, world of calculus we go!</p>
</section>
<section id="deriving-the-rate-of-change-fracdrridt-take-2-now-with-more-calculus" class="level1">
<h1>Deriving the Rate of Change: <span class="math inline">\(\frac{d(RRi)}{dt}\)</span> (Take 2, Now with More Calculus!)</h1>
<p>Our mission, should we choose to accept it (and we must!), is to differentiate the authentic RRi(t) equation with respect to time t. This derivative will tell us exactly how fast the RRi is increasing or decreasing at any given moment.</p>
<p>Let’s write the equation again, prepping it for differentiation by expressing the fractions using negative exponents:</p>
<p><span class="math display">\[
RRi(t) = \alpha + \beta \cdot [1 + \exp(\lambda(t - \tau))]^{-1} + (-c\beta) \cdot [1 + \exp(\phi(t - \tau - \delta))]^{-1}
\]</span></p>
<p>We’ll tackle this term by term, wielding the mighty chain rule like a seasoned warrior.</p>
</section>
<section id="step-1-derivative-of-the-constant-baseline" class="level1">
<h1>Step 1: Derivative of the Constant Baseline ()</h1>
<p>The baseline <span class="math inline">\(\alpha\)</span> is just a constant value, unchanging with time. Its rate of change is therefore zero. Zip. Nada.</p>
<p><span class="math display">\[
\frac{d}{dt}(\alpha) = 0
\]</span></p>
<p>Calculus is easy sometimes!</p>
</section>
<section id="step-2-derivative-of-the-first-logistic-term" class="level1">
<h1>Step 2: Derivative of the First Logistic Term (/ …)</h1>
<p>Now for the first real challenge: differentiating <span class="math inline">\(\beta \cdot [1 + \exp(\lambda(t - \tau))]^{-1}\)</span>.</p>
<p>Let’s use substitutions to make the chain rule clearer. Let <span class="math inline">\(u_1 = \lambda(t - \tau)\)</span>. Our term becomes <span class="math inline">\(\beta \cdot [1 + \exp(u_1)]^{-1}\)</span>.</p>
<p>The chain rule states <span class="math inline">\(\frac{d}{dt}[f(g(t))] = f'(g(t)) \cdot g'(t)\)</span>.</p>
<p>Let <span class="math inline">\(f(x) = \beta \cdot x^{-1}\)</span>. The derivative with respect to its argument x is <span class="math inline">\(f'(x) = -\beta \cdot x^{-2}\)</span>.</p>
<p>Let $ g(t) = 1 + (u_1)$ . We need its derivative <span class="math inline">\(g'(t) = \frac{d}{dt}[1 + \exp(u_1)]\)</span>. The derivative of 1 is 0, so <span class="math inline">\(g'(t) = \frac{d}{dt}[\exp(u_1)]\)</span>.</p>
<p>Time for another nested chain rule! Let <span class="math inline">\(h(u_1) = \exp(u_1)\)</span>, so <span class="math inline">\(h'(u_1) = \exp(u_1)\)</span>. We also need <span class="math inline">\(\frac{d(u_1)}{dt}\)</span>.</p>
<p>Since <span class="math inline">\(u_1 = \lambda(t - \tau) = \lambda t - \lambda \tau\)</span>, its derivative is <span class="math inline">\(\frac{d(u_1)}{dt} = \lambda\)</span>.</p>
<p>So, <span class="math inline">\(\frac{d}{dt}[\exp(u_1)] = h'(u_1) \cdot \frac{d(u_1)}{dt} = \exp(u_1) \cdot \lambda\)</span>.</p>
<p>Thus, <span class="math inline">\(g'(t) = \lambda \cdot \exp(u_1)\)</span>.</p>
<p>Now, let’s assemble the outer chain rule:</p>
<p><span class="math display">\[
\frac{d}{dt}[\beta \cdot (1 + \exp(u_1))^{-1}] = f'(g(t)) \cdot g'(t)
\]</span></p>
<p><span class="math display">\[
= [-\beta \cdot (1 + \exp(u_1))^{-2}] \cdot [\lambda \cdot \exp(u_1)]
\]</span></p>
<p><span class="math display">\[
= -\beta \lambda \frac{\exp(u_1)}{(1 + \exp(u_1))^2}
\]</span></p>
<p>Finally, substitute <span class="math inline">\(u_1 = \lambda(t - \tau)\)</span> back in:</p>
<p><span class="math display">\[
= -\beta \lambda \frac{\exp(\lambda(t - \tau))}{(1 + \exp(\lambda(t - \tau)))^2}
\]</span></p>
<p>Observe the negative sign that popped out! This term represents the rate of change due to the initial drop phase.</p>
</section>
<section id="step-3-derivative-of-the-second-logistic-term--cbeta-..." class="level1">
<h1>Step 3: Derivative of the Second Logistic Term (<span class="math inline">\(-c\beta / ...\)</span>)</h1>
<p>Next up: differentiating <span class="math inline">\((-c\beta) \cdot [1 + \exp(\phi(t - \tau - \delta))]^{-1}\)</span>.</p>
<p>Let <span class="math inline">\(u_2 = \phi(t - \tau - \delta)\)</span>. The term is <span class="math inline">\((-c\beta) \cdot [1 + \exp(u_2)]^{-1}\)</span>.</p>
<p>Again, using the chain rule <span class="math inline">\(\frac{d}{dt}[f(g(t))] = f'(g(t)) \cdot g'(t)\)</span>.</p>
<p>Let <span class="math inline">\(f(x) = (-c\beta) \cdot x^{-1}\)</span>. Then <span class="math inline">\(f'(x) = -(-c\beta) \cdot x^{-2} = c\beta \cdot x^{-2}\)</span>. (The negatives cancel!)</p>
<p>Let <span class="math inline">\(g(t) = 1 + \exp(u_2)\)</span>. Then <span class="math inline">\(g'(t) = \frac{d}{dt}[1 + \exp(u_2)] = \frac{d}{dt}[\exp(u_2)]\)</span>.</p>
<p>Nested chain rule for <span class="math inline">\(\exp(u_2)\)</span>: Let <span class="math inline">\(h(u_2) = \exp(u_2)\)</span>, so <span class="math inline">\(h'(u_2) = \exp(u_2)\)</span>. We need <span class="math inline">\(\frac{d(u_2)}{dt}\)</span>.</p>
<p>Since <span class="math inline">\(u_2 = \phi(t - \tau - \delta) = \phi t - \phi \tau - \phi \delta\)</span>, its derivative is <span class="math inline">\(\frac{d(u_2)}{dt} = \phi\)</span>.</p>
<p>So, <span class="math inline">\(\frac{d}{dt}[\exp(u_2)] = h'(u_2) \cdot \frac{d(u_2)}{dt} = \exp(u_2) \cdot \phi\)</span>. Thus, <span class="math inline">\(g'(t) = \phi \cdot \exp(u_2)\)</span>.</p>
<p>Assembling the outer chain rule: <span class="math display">\[
\frac{d}{dt}[(-c\beta) \cdot (1 + \exp(u_2))^{-1}] = f'(g(t)) \cdot g'(t)
\]</span></p>
<p><span class="math display">\[
= [c\beta \cdot (1 + \exp(u_2))^{-2}] \cdot [\phi \cdot \exp(u_2)]
\]</span></p>
<p><span class="math display">\[
= c \beta \phi \frac{\exp(u_2)}{(1 + \exp(u_2))^2}
\]</span></p>
<p>Substituting <span class="math inline">\(u_2 = \phi(t - \tau - \delta)\)</span> back in:</p>
<p><span class="math display">\[
= c \beta \phi \frac{\exp(\phi(t - \tau - \delta))}{(1 + \exp(\phi(t - \tau - \delta)))^2}
\]</span></p>
<p>This term represents the rate of change contributed by the recovery phase.</p>
</section>
<section id="step-4-combine-the-derivatives" class="level1">
<h1>Step 4: Combine the Derivatives</h1>
<p>The derivative of the sum is the sum of the derivatives. So, we add the results from steps 1, 2, and 3: <span class="math display">\[
\frac{d(RRi)}{dt} = 0 + \left[ -\beta \lambda \frac{\exp(\lambda(t - \tau))}{(1 + \exp(\lambda(t - \tau)))^2} \right] + \left[ c \beta \phi \frac{\exp(\phi(t - \tau - \delta))}{(1 + \exp(\phi(t - \tau - \delta)))^2} \right]
\]</span></p>
<p>Cleaning it up, our final rate of change equation is:</p>
<p><span class="math display">\[
\frac{d(RRi)}{dt} = -\beta \lambda \frac{\exp(\lambda(t - \tau))}{(1 + \exp(\lambda(t - \tau)))^2} + c \beta \phi \frac{\exp(\phi(t - \tau - \delta))}{(1 + \exp(\phi(t - \tau - \delta)))^2}
\]</span></p>
<p>This equation is the heart of the dynamics for our integrator. It calculates the instantaneous slope (the speed and direction of change) of the RRi(t) curve at any given time t. It’s the recipe the integrator needs to figure out where to go next.</p>
</section>
<section id="implementing-the-specific-derivative-function-in-r" class="level1">
<h1>Implementing the Specific Derivative Function in R</h1>
<p>Now, we translate this beautiful (or terrifying, depending on your relationship with calculus) derivative formula into R code. We need to be careful with signs and ensure all the parameters (<span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\lambda\)</span>, <span class="math inline">\(\tau\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\delta\)</span>) are correctly used.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Derivative of the *Specific* Castillo-Aguilar Double Logistic Function w.r.t. time (t)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># This function calculates d(RRi)/dt at a specific time 't'.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># This is the function needed as the 'static_function' for the leapfrog integrator.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>rri_double_logistic_derivative <span class="ot">&lt;-</span> <span class="cf">function</span>(t, alpha, beta, lambda, tau, c_param, phi, delta) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Parameters are the same as rri_double_logistic:</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># t ($t$), alpha ($\alpha$), beta ($\beta$), lambda ($\lambda$), tau ($\tau$),</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># c_param ($c$), phi ($\phi$), delta ($\delta$)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Calculate terms for the first component's derivative</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Corresponds to: $-\beta \lambda \exp(\lambda(t - \tau)) / (1 + \exp(\lambda(t - \tau)))^2$</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  exp_term1 <span class="ot">&lt;-</span> <span class="fu">exp</span>(lambda <span class="sc">*</span> (t <span class="sc">-</span> tau))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Note the crucial minus sign from the derivation: -beta * lambda * ...</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  deriv_comp1 <span class="ot">&lt;-</span> <span class="sc">-</span>beta <span class="sc">*</span> lambda <span class="sc">*</span> exp_term1 <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">+</span> exp_term1)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Calculate terms for the second component's derivative</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Corresponds to: $c \beta \phi \exp(\phi(t - \tau - \delta)) / (1 + \exp(\phi(t - \tau - \delta)))^2$</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  exp_term2 <span class="ot">&lt;-</span> <span class="fu">exp</span>(phi <span class="sc">*</span> (t <span class="sc">-</span> tau <span class="sc">-</span> delta))</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Note the positive sign here: c_param * beta * phi * ...</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  deriv_comp2 <span class="ot">&lt;-</span> c_param <span class="sc">*</span> beta <span class="sc">*</span> phi <span class="sc">*</span> exp_term2 <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">+</span> exp_term2)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># The derivative of alpha is 0, so we just sum the component derivatives</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  dRRi_dt <span class="ot">&lt;-</span> deriv_comp1 <span class="sc">+</span> deriv_comp2</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(dRRi_dt)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage (using the same parameters as before)</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>rate_of_change <span class="ot">&lt;-</span> <span class="fu">rri_double_logistic_derivative</span>(<span class="at">t =</span> time_point,</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">alpha =</span> baseline_alpha,</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">beta =</span> drop_amplitude_beta,</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">lambda =</span> drop_steepness_lambda,</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">tau =</span> drop_time_tau,</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">c_param =</span> recovery_factor_c,</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">phi =</span> recovery_steepness_phi,</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                                                 <span class="at">delta =</span> recovery_delay_delta)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(time_point, rate_of_change, <span class="at">type =</span> <span class="st">"l"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="rri-dynamics_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Fantastic. Our R code now perfectly mirrors the derived d(RRi)/dt formula. This function is ready to be plugged into the leapfrog integrator as the core ‘dynamics’ or ‘force’ function (if we were thinking in physics terms).</p>
</section>
<section id="defining-the-gradient-for-the-leapfrog-integrator-the-sound-of-silence-still-zero" class="level1">
<h1>Defining the Gradient for the Leapfrog Integrator (The Sound of Silence: Still Zero!)</h1>
<p>Now, for the final piece required by some integrators like the Velocity Verlet variant of leapfrog: the gradient. This means we need to know how the rate of change itself changes if the current state changes. Mathematically, we need the derivative of our <span class="math inline">\(\frac{d(RRi)}{dt}\)</span> function with respect to the state variable, RRi. Let’s denote this as <span class="math inline">\(\frac{d}{d(RRi)}\left[\frac{d(RRi)}{dt}\right]\)</span>.</p>
<p>In systems where the rate of change depends on the current state (e.g., population growth depending on current population size, or our very first simple heart rate model), this gradient is non-zero and crucial. It tells the integrator how the ‘velocity’ field changes as you move through the state space.</p>
<p>But let’s scrutinize our hard-earned rate of change equation one more time: <span class="math display">\[
\frac{d(RRi)}{dt} = -\beta \lambda \frac{\exp(\lambda(t - \tau))}{(1 + \exp(\lambda(t - \tau)))^2} + c \beta \phi \frac{\exp(\phi(t - \tau - \delta))}{(1 + \exp(\phi(t - \tau - \delta)))^2}
\]</span></p>
<p>Look closely at the right-hand side. It contains time (t) and a whole bunch of fixed parameters (<span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\lambda\)</span>, <span class="math inline">\(\tau\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\delta\)</span>). But where is the variable RRi (the current R-R interval)? It’s nowhere to be found! The rate of change, according to this specific model, is entirely determined by what time it is (t) and the fixed shape parameters, not by the current value of RRi.</p>
<p>What happens when you differentiate an expression with respect to a variable that doesn’t appear in it? The result is a resounding ZERO.</p>
<p><span class="math display">\[
\frac{d}{d(RRi)}\left[\frac{d(RRi)}{dt}\right] = 0
\]</span></p>
<p>This is a key feature (or limitation, depending on your perspective) of this type of time-driven model. The trajectory is predetermined by the clock and the parameters; the system doesn’t dynamically react to its own current state value when deciding its rate of change. For our leapfrog integrator, this means the gradient calculation becomes wonderfully trivial.</p>
</section>
<section id="implementing-the-gradient-function-in-r-elegantly-simple" class="level1">
<h1>Implementing the Gradient Function in R (Elegantly Simple)</h1>
<p>So, the R function for the gradient, while needing all the parameters in its signature to potentially match the integrator’s requirements, has the simplest possible implementation: it just returns 0.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Gradient of the *Specific* Castillo-Aguilar RRi rate-of-change function w.r.t. RRi</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># This function calculates d/d(RRi) [d(RRi)/dt]</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>gradient_rri_derivative <span class="ot">&lt;-</span> <span class="cf">function</span>(current_rri, t, alpha, beta, lambda, tau, c_param, phi, delta) {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># current_rri: The current RRi value (state variable, $RRi$)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># t: The current time ($t$)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Other parameters: Model parameters ($\alpha, \beta, \lambda, \tau, c, \phi, \delta$)</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Since d(RRi)/dt, as defined by the Castillo-Aguilar model,</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># does NOT explicitly depend on the current value of RRi,</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># its derivative with respect to RRi is simply 0.</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="dv">0</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And that concludes our expanded tour! We’ve meticulously dissected the specific Castillo-Aguilar et al.&nbsp;(2025) model, translated it and its time derivative into R, performed the necessary calculus with extra commentary, formatted our math nicely, and confirmed the gradient needed by the leapfrog integrator is zero for this particular time-driven model. Your simulation toolkit is now properly calibrated and significantly better explained!</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>