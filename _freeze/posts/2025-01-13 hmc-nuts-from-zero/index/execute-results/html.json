{
  "hash": "85d53de16ac89d562716c0a8e483c060",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Going NUTS: A Step-by-Step Guide to Adaptive Hamiltonian Sampling in R\"\ndescription: |\n  You may have wonder what's the engine behind many Bayesian analysis in modern research? Well, in this post we'll not only cover the fundamentals, but we'll also build from the ground-up a fully functional Hamiltonian Monte Carlo with No-U-Turn-Sampler (HMC-NUTS), the bad boy behind the hood of the Bayesian inference monster truck.\ndate: \"2025-01-13\"\n\n# doi: \"10.59350/mgpv2-d5e33\"\n\ndraft: true\ndraft-mode: unlinked\n\nexecute: \n  warning: false\n  error: false\n\ncategories: [HMC, MCMC, algorithms, educational]\n\nbibliography: ref.bib\n\ntitle-block-banner: title-block.png\nimage: body_1.png\n\neditor_options: \n  chunk_output_type: console\n\ncode-links:\n  - text: R Functions Used\n    href: hmc-nuts-functions.R\n    icon: file-code\n\nresources:\n  - demo-mcmc/\n  - hmc-nuts-functions.R\n---\n\n\n\n\n\n# Introduction\n\nRemember MCMC from our series on these algorithms? Good times. We wandered through probability space like tourists with outdated maps, occasionally stumbling upon the good parts of the posterior. Then came Hamiltonian Monte Carlo (HMC), which, let's be honest, felt like finally getting a GPS. We could *actually* explore the posterior, using gradients to guide our journey. It was efficient! It was elegant! It was… still kind of a pain in the neck.\n[Check our [first post](https://doi.org/10.59350/mxfyk-6av39) on MCMC principles and use cases before diving into this post, if you haven't done it already.]{.aside}\n\n#### Why Your HMC Was Probably Just Running in Circles\n\nSee, HMC, for all its brilliance, has this one little quirk: it needs to be told how far to travel in each step. It's like having a GPS that only understands instructions in increments of \"exactly 5 kilometers\". Want to go 4.8 km? Too bad. Want to go 5.2 km? Tough luck. This \"step size\" parameter is crucial. Too small, and you’re just shuffling around like a confused shopper in a supermarket, making painfully slow progress. Too large, and you're overshooting your target, bouncing around like a pinball, and generally wasting everyone's time (especially your computer’s).\n[Check our [second post](https://doi.org/10.59350/mxfyk-6av39) on MCMC, more specifically on HMC, to get a better intuition of what this algorithm is doing.]{.aside}\n\nThis manual tuning of the step size is about as fun as watching paint dry. You fiddle with it, run your sampler, check the results, fiddle some more, run it again… It's an iterative process that makes you question your life choices. You start to wonder if there’s a better way. A way to tell the sampler, \"Hey, just go where you need to go, okay?\"\n\nEnter the No-U-Turn Sampler (NUTS). Yes, it's a ridiculous name. But it's also a brilliant solution. NUTS is like giving your HMC GPS a brain. It dynamically figures out how far to travel in each step, adapting to the local geometry of the posterior. No more tedious manual tuning! No more endless tweaking! NUTS takes the wheel and drives you straight to the heart of the posterior distribution, efficiently exploring even the most complex landscapes.\n\nIn this post, we're going to dive deep into the inner workings of NUTS. We’ll explore how it cleverly avoids those wasteful U-turns (hence the name), how it builds efficient trajectories, and how you can implement it yourself in R. By the end, you'll be able to unleash the power of adaptive Hamiltonian sampling on your own Bayesian models, and finally say goodbye to the tyranny of fixed step sizes. You'll learn how to transform your sampling from a tedious chore into a smooth, efficient, and (dare I say) even enjoyable experience. So buckle up, because we're about to go NUTS!\n\n# When Your Posterior Looks Like a Jackson Pollock Painting\n\nSo, we know HMC with fixed step sizes can be a bit… finicky. But why should we care? Are there actual problems where this matters? You bet your Bayesian priors there are! Imagine you're trying to model something complex, like the spread of a disease, the performance of a stock portfolio, or the migratory patterns of extremely confused pigeons. These kinds of problems often lead to posterior distributions that are… well, let’s just say they’re not always nice, well-behaved Gaussians.\n\nSometimes, your posterior might have multiple peaks (multimodal), like a mountain range with several summits. Traditional MCMC methods, like Metropolis-Hastings or Gibbs sampling, can get stuck in one peak, completely missing the others. It's like trying to find all the best restaurants in a city by only exploring one neighborhood. You might find a decent burger joint, but you'll miss out on the amazing sushi place across town.\n\nFixed-step HMC fares a little better, thanks to its gradient-based exploration. But even it can struggle. Imagine trying to navigate that same mountain range with a vehicle that can only move in fixed increments. If the step size is too large, you might overshoot the peaks and bounce around erratically. If it's too small, you'll take forever to explore the terrain. And if the terrain is particularly treacherous—say, with narrow valleys and steep cliffs, you might get stuck altogether.\n\nA particularly illustrative example is a posterior with a \"banana-shaped\" density. This isn't some exotic fruit we're talking about; it's a type of distribution that curves like a banana. These curved, elongated shapes are common in hierarchical models and other complex statistical models. They present a challenge for fixed-step HMC because the optimal step size varies drastically across the distribution. A small step size might be necessary in the curved part of the \"banana,\" while a much larger step size would be more efficient in the straighter parts.\n\nTo make this concrete, let's consider a simple bivariate Gaussian distribution with a banana-shaped density. We can define this as follows:\n\n$$\n\\begin{aligned}\nx &\\sim \\mathcal{N}(0, 1) \\\\\ny &\\sim \\mathcal{N}(x^2, 0.1)\n\\end{aligned}\n$$\n\nThis creates a posterior where $y$ is dependent on $x^2$, resulting in the characteristic banana shape.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nxy_seq <- seq(-3, 3, .01)\ndf <- expand.grid(x = xy_seq, y = xy_seq)\ndf$z <- with(df, {\n  x_square <- (x^2)\n  yx_square <- ((y - x_square)^2) / .1\n  exp(-0.5 * x_square - 0.5 * yx_square)\n})\n\nggplot(df, aes(x, -y, z = z)) +\n  geom_raster(aes(fill = z), show.legend = FALSE) +\n  geom_contour(bins = 8, show.legend = FALSE, alpha = .1, col = \"#206080\") +\n  scale_y_continuous(limits = c(-3,2), expand = c(0,0), \n                     oob = scales::squish_infinite) +\n  scale_x_continuous(limits = c(-2,2), expand = c(0,0), \n                     oob = scales::squish_infinite) +\n  scale_fill_gradient(low = \"white\", high = \"#B7CCDC\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.svg)\n:::\n:::\n\n\n\nAs you can see, this posterior is far from a simple, spherical Gaussian. Trying to efficiently sample from this distribution with a fixed step size is like trying to fit a square peg in a round hole (or, in this case, a banana-shaped hole). \n\n# How to Not Get Lost in Probability Space\n\nNow that we understand why fixed-step HMC can struggle, let's dig into the magic behind NUTS. The core idea is to let the sampler *decide* how far to travel in each step, adapting to the local geometry of the posterior. This involves two key components: adaptive path length and the U-turn criterion.\n\n#### Adaptive Path Length\n\nIn fixed-step HMC, you predefine a fixed number of leapfrog steps. This determines the length of the trajectory. But what if the optimal trajectory length varies across the posterior? What if sometimes you need to take a short stroll and other times a long hike?\n\nNUTS solves this by dynamically adjusting the trajectory length. It starts with a short trajectory (e.g., just one leapfrog step) and then *doubles* it repeatedly. This doubling process continues until a certain criterion is met (which we’ll get to in the next subsection).\n\nWhy doubling? Because it’s efficient! It allows NUTS to quickly explore a wide range of trajectory lengths without having to try every single possible length. It's like searching for a light switch in a dark room: you start by checking nearby, then you check a wider area, and so on, doubling your search radius until you find it.\n\nNow, let's consider a 2D example. Remember our banana-shaped posterior? In NUTS, we start with a single leapfrog step in a random direction. Then, we double the trajectory length by taking two steps, then four, and so on. The trajectory starts to resemble a branching path, exploring the posterior in ever-widening arcs.\n\nLet's now see **an interactive animation** of the NUTS dynamics in action over our banana-shaped distribution.\n\n<iframe width=\"100%\" height=\"500\" src=\"demo-mcmc/app.html\" title=\"MCMC\"></iframe>\n[The code for this animation is borrowed from [Chi Feng's github](https://github.com/chi-feng). You can find the original repository with corresponding code here: <https://github.com/chi-feng/mcmc-demo>]{.aside}\n\nThis dynamic doubling of the trajectory length is a crucial part of NUTS's efficiency. It allows the sampler to quickly adapt to the local geometry of the posterior, taking long steps when appropriate and short steps when necessary. But how does NUTS know when to stop doubling? That's where the U-turn criterion comes in, which we'll explore in the next section.\n\n#### The U-Turn Criterion\n\nSo, we're doubling the trajectory length, exploring the posterior like eager adventurers. But how do we know when to stop? We don't want to keep doubling indefinitely, wasting computational resources and potentially revisiting already explored regions. This is where the U-turn criterion comes in.\n\nThe basic idea is simple: if our trajectory starts to double back on itself—making a \"U-turn\"—it's a good sign that we've explored the relevant part of the posterior in that direction. Continuing further would just be redundant. It's like hiking up a mountain: once you reach the summit and start heading down the other side, you know you've gone far enough in that direction. No need to keep walking just for the sake of it (unless you're really into hiking, I guess).\n\nMathematically, a U-turn is detected by looking at the dot product of the momentum vectors at the beginning and end of the trajectory. Remember, the momentum vector indicates the direction of travel. If the dot product is negative, it means the two momentum vectors are pointing in roughly opposite directions—a clear sign of a U-turn.\n\nLet's break this down with a small example. Imagine we're sampling from a 2D Gaussian. We start at a point $q_0$ with momentum $p_0$. We take a few leapfrog steps and end up at a point $q_T$ with momentum $p_T$.\n\n*   If $p_0 \\cdot p_T > 0$, the momentum vectors are pointing in roughly the same direction. No U-turn yet. Keep exploring!\n*   If $p_0 \\cdot p_T < 0$, the momentum vectors are pointing in roughly opposite directions. We've made a U-turn! Time to stop doubling the trajectory in this direction.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nq0 <- c(1, 1)\np0 <- c(-1, 1)\nepsilon <- 0.1\nsteps <- 60\nSigma <- diag(1,2)\n\nxy_seq <- seq(-3, 3, by = .1)\ndens_df <- expand.grid(x = xy_seq, y = xy_seq)\ndens_df$z <- mvtnorm::dmvnorm(dens_df, c(0,0), Sigma)\n\npositions <- matrix(0, nrow = steps, ncol = length(q0))\npositions[1, ] <- q0\n\n## Simplified leapfrog steps\nq <- q0; p <- p0\nfor (i in 2:steps) {\n  p_half <- p + (epsilon / 2) * (-q)  # Half-step for momentum\n  q <- q + epsilon * p_half           # Full-step for position\n  p <- p_half + (epsilon / 2) * (-q)  # Second half-step for momentum\n  positions[i, ] <- q\n}\n\n# Check U-Turn\nuturn_check <- apply(positions, 1, function(qp) {\n  sum((qp - q0) * p0) < 0\n})\n\nplot_data <- data.table(x = positions[, 1], \n                        y = positions[, 2], \n                        is_uturn = uturn_check)\n\nggplot(plot_data, aes(x = x, y = y)) +\n  geom_contour(data = dens_df, aes(x, y, z = z), col = \"gray\", \n               linetype = 2) +\n  geom_point(aes(color = is_uturn), size = 3) +\n  geom_path(aes(color = is_uturn, group = 1)) +\n  annotate(geom = \"segment\", \n           x = q0[1], y = q0[2], \n           xend = q0[1] + p0[1], yend = q0[2] + p0[2], \n           arrow = arrow(length = unit(1/3, \"cm\"), type = \"closed\"), \n           lwd = 1, linejoin = \"mitre\") +\n  labs(title = \"U-Turn Check\", \n       x = expression(q[1]), \n       y = expression(q[2])) +\n  scale_color_manual(values = c(\"#008080\", \"#990050\"), \n                     labels = c(\"No U-Turn\", \"U-Turn\"),\n                     name = \"U-Turn State\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.svg)\n:::\n:::\n\n\n\nThis U-turn criterion is a clever way to prevent NUTS from over-exploring. It ensures that the sampler focuses its efforts on the relevant regions of the posterior, leading to more efficient sampling. Now that we know how NUTS adapts the trajectory length and when to stop, let's see how it organizes these trajectories into a neat and efficient structure: the binary tree.\n\n#### Tree Building for Sampling\n\nWe now know how NUTS dynamically adjusts the trajectory length and how it uses the U-turn criterion to avoid redundant sampling. But how does it keep track of all these different trajectories? The answer is: with a binary tree!\n\nImagine you're exploring a maze. You start at the entrance, and at each intersection, you have two choices: go left or go right. You keep making choices until you reach a dead end or decide to turn back. This is essentially how NUTS builds its binary tree.\n\nNUTS starts with a single leapfrog step (our initial trajectory). This is the root of our tree. Then, it doubles the trajectory length by taking two steps: one to the \"left\" and one to the \"right.\" These two trajectories become the children of the root node. This doubling process continues, creating a balanced binary tree.\n\nWhy a tree? Because it's an efficient way to organize the exploration. It allows NUTS to quickly explore different parts of the posterior without having to revisit already explored regions (thanks to the U-turn criterion).\n\nLet's break down the tree-building process:\n\n1.  **Start with a single leapfrog step:** This is the root node of the tree.\n2.  **Double the trajectory length:** Create two new trajectories by extending the current trajectory in both directions (forward and backward in time). These are the left and right children of the current node.\n3.  **Check for U-turns:** Use the U-turn criterion to determine if either of the new trajectories has made a U-turn. If so, stop extending that branch of the tree.\n4.  **Repeat steps 2 and 3:** Continue doubling the trajectory length and checking for U-turns until a certain stopping criterion is met (e.g., a maximum tree depth).\n\n![](tree-example.png){.img-fluid width=\"100%\"}\n[Photo from [J. Mach. Learn. Res., 15(1), 1593-1623](https://www.jmlr.org/papers/volume15/hoffman14a/hoffman14a.pdf).]{.aside}\n\nNow, how does NUTS use this tree for sampling? It uses a process called recursive sampling. It starts at the root node and recursively traverses the tree, choosing either the left or right child at each node. The choice is made probabilistically, based on the Metropolis-Hastings acceptance criterion. This ensures that the samples are drawn from the target posterior distribution.\n\nThis tree-building and recursive sampling process is what makes NUTS so efficient. It allows it to explore the posterior in a structured and organized way, avoiding redundant sampling and quickly adapting to the local geometry.\n\n# Step-by-Step Implementation of NUTS\n\nNow that we understand the theory behind NUTS, it's time to put our knowledge into practice. In this section, we'll build a NUTS sampler from scratch in R. Don't worry, we'll take it one step at a time (or, should I say, one leapfrog step at a time?).\n\n#### Setting Things Up\n\nBefore we start building our NUTS engine, we need to gather our tools. This involves defining our target distribution, its gradient, and the leapfrog integration method. We'll reuse the gradient and leapfrog functions from our previous HMC implementation (because why reinvent the wheel?).\n\nLet's consider a simple 2D Gaussian distribution as our target posterior. This will make it easier to visualize and understand the behavior of NUTS. We can define the log-posterior as follows:\n\n$$\n\\log p(q) = -\\frac{1}{2}q^\\top \\Sigma^{-1} q -\\frac{1}{2}\\log(\\det{\\Sigma}) + \\text{constant}\n$$\n\nWhere $q = (q_1, q_2)$ is our position vector and $\\Sigma$ is the covariance matrix.\n\nNow, let's define the gradient of the log-posterior:\n\n$$\n\\nabla \\log p(q) = -\\Sigma^{-1} q\n$$\n\nHere's the R code for the log-posterior and its gradient:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Log-posterior function\nlog_posterior <- function(q, Sigma, mu) {\n  diff <- q - mu\n  -0.5 * t(diff) %*% solve(Sigma) %*% diff - 0.5 * log(det(Sigma))\n}\n\n## Gradient of Log-posterior\ngrad_log_posterior <- function(q, Sigma, mu) {\n  -solve(Sigma, q - mu)\n}\n```\n:::\n\n\n\nNext, we need the leapfrog integration function. Here's a reminder (and the R code) from the previous HMC blog post:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Leapfrog integration\nleapfrog <- function(q, p, grad_func, epsilon, Sigma, mu) {\n  grad_q <- grad_func(q, Sigma, mu) # Gradient calculation\n  p <- p + (epsilon / 2) * grad_q # Half-step for momentum\n  q <- q + epsilon * p # Full-step for position\n  grad_q <- grad_func(q, Sigma, mu)\n  p <- p + (epsilon / 2) * grad_q # Half-step for momentum\n  list(q = q, p = p)\n}\n```\n:::\n\n\n\nWith these functions in place, we're ready to start implementing the core components of NUTS. We'll begin with the initialization step in the next subsection.\n\nOkay, let's dive into the core steps of NUTS implementation. This will be the most substantial part of the implementation section.\n\n#### Core Steps of NUTS\n\nNow that we have our tools ready, we can start building the core components of the NUTS sampler. This involves initialization, building the trajectory, checking for U-turns, building the tree, and handling acceptance and termination.\n\n##### Initialization\n\nFirst, we need to initialize the sampler. This involves setting the initial position $q$, drawing a random momentum $p$, and setting the hyperparameters, most importantly, the initial step size $\\epsilon$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initialization\nnuts_init <- function(q0, Sigma, mu, epsilon) {\n  list(\n    q = q0, # Initial position\n    mu = mu,\n    p = rnorm(length(q0), 0, 1), # Initial random momentum\n    epsilon = epsilon # Initial step size (this will be adapted later)\n  )\n}\n\n# Example initialization\nq0 <- c(0, 0) # Starting position\nmu <- c(-1,1) # Target location\nepsilon = 0.1 # Step size\n\nnuts_state <- nuts_init(q0, Sigma, mu, epsilon)\n```\n:::\n\n\n\n##### Build the Trajectory\n\nThe next step is to build the trajectory using the leapfrog integrator. Here's where the dynamic doubling comes in. We’ll also incorporate the U-turn check here.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\n# U-turn check (dot product of momentum vectors)\nis_uturn <- function(q_left, q_right, p_left, p_right) {\n  (sum((q_right - q_left) * p_left) < 0) || \n    (sum((q_right - q_left) * p_right) < 0)\n}\n\n# Build a trajectory (doubling until U-turn)\nbuild_trajectory <- function(q, p, grad_func, epsilon, Sigma, mu) {\n  q_left <- q\n  p_left <- p\n  q_right <- q\n  p_right <- p\n  trajectory <- list(q = q, p = p)\n  \n  j <- 0\n  while (!is_uturn(q_left, q_right, p_left, p_right) && j < 10) {\n    if (runif(1) < 0.5) {\n      # Expand left\n      leapfrog_result <- leapfrog(q_left, p_left, grad_func, -epsilon, Sigma, mu)\n      q_left <- leapfrog_result$q\n      p_left <- leapfrog_result$p\n    } else {\n      # Expand right\n      leapfrog_result <- leapfrog(q_right, p_right, grad_func, epsilon, Sigma, mu)\n      q_right <- leapfrog_result$q\n      p_right <- leapfrog_result$p\n    }\n    trajectory$q <- cbind(trajectory$q, leapfrog_result$q)\n    trajectory$p <- cbind(trajectory$p, leapfrog_result$p)\n    j <- j + 1\n  }\n  index <- sample(1:ncol(trajectory$q), 1)\n  list(q = trajectory$q[, index], p = trajectory$p[, index])\n}\n```\n:::\n\n\n\n##### Tree Building\n\nWhile the previous function *builds* the trajectory by doubling it, the actual tree structure is implicit. This is because NUTS doesn't explicitly store the entire tree in memory. It only needs to keep track of the leftmost and rightmost points of the trajectory and use them to sample.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nnsteps <- 1000\npositions <- matrix(NA, nrow = nsteps, ncol = 2)\n\nxy_seq <- seq(-.5, 3, by = .1)\ndens_df <- expand.grid(x = xy_seq, y = xy_seq)\ndens_df$z <- mvtnorm::dmvnorm(dens_df, c(0,0), diag(1,2))\n\nset.seed(42)\nfor (i in seq_len(nsteps)) {\n  positions[i,] <- build_trajectory(\n    q = c(1, 1),\n    p = c(-1, 1),\n    grad_func = grad_log_posterior,\n    epsilon = 0.1,\n    Sigma = diag(1,2),\n    mu = c(0,0)\n  )$q\n}\n\npositions <- unique(positions) |> \n  data.table::as.data.table()\n\npositions[V1 > 1, side := \"Right\"]\npositions[V1 < 1, side := \"Left\"]\npositions[V1 == 1, side := \"Initial Position\"]\n\nggplot(positions, aes(x = V1, y = V2)) +\n  geom_contour(data = dens_df, aes(x, y, z = z), col = \"gray\", \n               linetype = 2) +\n  geom_line(linewidth = 1) +\n  geom_line(aes(col = side), linewidth = 1) +\n  geom_point(aes(col = side), size = 3) +\n  labs(title = \"Binary Tree Trajectory Visualization\", \n       x = expression(q[1]), y = expression(q[2]),\n       col = \"Tree Side\") +\n  scale_color_manual(values = c(rgb(0,0.5,0.5,1),\n                                rgb(0.5,0,0.5,1),\n                                rgb(0.2,0.2,0.2,1)),\n                     breaks = c(\"Left\", \"Right\")) +\n  annotate(geom = \"text\", \n           x = positions[side==\"Left\"][order(V2), V1],\n           y = positions[side==\"Left\"][order(V2), V2] + .1,\n           label = 1:8, col = rgb(0,0.3,0.3,1)) +\n  annotate(geom = \"text\", \n           x = positions[side==\"Right\"][order(V1), V1] + .05,\n           y = positions[side==\"Right\"][order(V1), V2],\n           label = 1:8, col = rgb(0.3,0,0.3,1)) +\n  scale_x_continuous(expand = c(0,0)) +\n  scale_y_continuous(expand = c(0,0))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.svg)\n:::\n:::\n\n\n\n##### Acceptance and Termination\n\nFinally, we need to decide whether to accept the new sample from the trajectory. This is done using the Metropolis-Hastings acceptance criterion, comparing the joint probability of the initial state and the proposed state. The process is repeated until the desired number of samples is obtained.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Metropolis-Hastings acceptance probability\nacceptance_prob <- function(current_logp, proposed_logp) {\n  min(1, exp(proposed_logp - current_logp))\n}\n```\n:::\n\n\n\nWe will incorporate this acceptance step into the full NUTS sampler in the next section, along with the complete NUTS algorithm and the adaptive step size procedure.\n\n##### Adaptative Epsilon\n\nOne of the most crucial aspects of NUTS (and HMC in general) is choosing an appropriate step size, $\\epsilon$. A good step size allows the sampler to efficiently explore the posterior distribution. Too small, and the sampler takes tiny, slow steps, like a snail on a marathon. Too large, and it overshoots, bouncing around erratically, like a caffeinated kangaroo on a trampoline.\n\nNUTS uses an adaptive step size procedure, especially during the warmup phase, to find a good value for $\\epsilon$. The goal is to achieve a target acceptance rate, typically around 0.8. This indicates that the sampler is neither accepting too many nor too few proposals.\n\nA simple way to adapt the step size is to use the following update rule:\n\n$$\n\\epsilon \\leftarrow \\epsilon \\cdot e^{\\gamma \\cdot \\delta} \\\\\n$$\n\nWhere $\\epsilon$ is the current step size; $\\gamma$ is a tuning parameter that controls the adaptation rate (how fast $\\epsilon$ will adapt); $\\delta$ is the difference between the current acceptance rate $\\lambda_{\\text{CA}}$ and the target acceptance rate $\\lambda_{\\text{TA}}$, and could be defined like this:\n\n$$\n\\delta = \\lambda_{\\text{CA}} - \\lambda_{\\text{TA}}\n$$\n\nThis simplified form allow us to reduce epsilon at each step as long as the current acceptance rate $\\lambda_{\\text{CA}}$ is lower than the target acceptance rate $\\lambda_{\\text{TA}}$. Here's the R code for this adaptation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nadapt_epsilon <- function(epsilon, lambda_ca, lambda_ta = 0.8, gamma = 0.5) {\n  delta <- lambda_ca - lambda_ta\n  epsilon <- epsilon * exp(gamma * delta)\n  epsilon\n}\n```\n:::\n\n\n\nThis update rule adjusts the step size based on the difference between the observed and target acceptance rates. If the acceptance rate is too low, ($\\epsilon$) is decreased; if it's too high, ($\\epsilon$) is increased. The ($\\gamma$) parameter controls how aggressively this adjustment is made.\n\nTo see how this adaptation works in practice, let's visualize its dynamics:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nepsilons <- numeric(50)\n  accept_rates <- seq(0, 0.9, length.out = 50)\n  epsilons[1] <- 1.0\n  gammas <- seq(0, 0.30, by = 0.025)\n  plot_data <- list()\n  \n  for (i in seq_along(gammas)) {\n    for (j in 2:length(epsilons)) {\n      epsilons[j] <- adapt_epsilon(\n        epsilon = epsilons[j - 1], \n        lambda_ca = accept_rates[j], \n        lambda_ta = 0.8,\n        gamma = gammas[i])\n    }\n    plot_data[[i]] <- data.table::data.table(\n      iteration = 1:50,\n      epsilon = epsilons,\n      gamma = gammas[i],\n      accept_rate = accept_rates\n    )\n  }\n  \n  plot_data <- data.table::rbindlist(plot_data)\n  \n  ggplot(plot_data, aes(x = iteration, y = epsilon, col = gamma, group = gamma)) +\n    geom_line(aes(linewidth = accept_rate, alpha = accept_rate)) +\n    labs(title = \"Epsilon Adaptation\", x = \"Iteration\", \n         y = \"Epsilon\", col = expression(\"Adaptation Rate (\"*gamma*\")\")) +\n    geom_hline(yintercept = 1, linewidth = 1/2, color = \"gray50\", linetype = 2) +\n    scale_alpha_continuous(range = c(0.3,1), name = \"Acceptance Rate\",\n                           labels = scales::label_percent(),\n                           limits = c(0, .9), \n                           breaks = c(0, .3, .6, .9)) +\n    scale_linewidth_continuous(range = c(0.1, 1.5), \n                               name = NULL, labels = NULL, breaks = NULL) +\n    scale_x_continuous(expand = c(0,0)) +\n    scale_color_viridis_c(limits = c(0, .31))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.svg)\n:::\n:::\n\n\n\nAs the plot shows, the adaptation is more aggressive (epsilon changes more rapidly) with larger values of gamma. Note that this is a very basic adaptation strategy. More robust methods, such as dual averaging, are typically used in practice, but this simple method illustrates the basic idea. \n\n#### Implementation Strategy\n\nNow that we have all the individual components, it's time to assemble them into a fully functional NUTS sampler. We'll also incorporate the adaptive step size tuning, which is crucial for NUTS's performance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Full NUTS sampler\nnuts <- function(log_posterior, grad_log_posterior, \n                 q0, Sigma, mu, \n                 epsilon, lambda_ta, gamma,\n                 n_samples = 1000, n_warmup = 500) {\n  # Initialization\n  nuts_state <- nuts_init(q0, Sigma, mu, epsilon)\n  samples <- matrix(0, nrow = n_samples + n_warmup, ncol = length(q0))\n  \n  # Warmup phase for step size adaptation\n  for (i in 1:n_warmup) {\n    nuts_state$p <- rnorm(length(q0), 0, 1) # Resample momentum\n    trajectory <- build_trajectory(nuts_state$q, nuts_state$p, grad_log_posterior, nuts_state$epsilon, Sigma, mu)\n    \n    #Metropolis Hastings\n    current_logp <- log_posterior(nuts_state$q, Sigma, mu)\n    proposed_logp <- log_posterior(trajectory$q, Sigma, mu)\n  \n    acc_rate <- acceptance_prob(current_logp, proposed_logp)\n    \n    if(runif(1) < acc_rate){\n      nuts_state$q <- trajectory$q\n    }\n    \n    ## Adaptative epsilon\n    nuts_state$epsilon <- adapt_epsilon(epsilon, acc_rate, lambda_ta, gamma)\n    \n    samples[i, ] <- nuts_state$q\n  }\n  \n  # Sampling phase\n  for (i in 1:n_samples) {\n    nuts_state$p <- rnorm(length(q0), 0, 1) # Resample momentum\n    trajectory <- build_trajectory(nuts_state$q, nuts_state$p, grad_log_posterior, nuts_state$epsilon, Sigma, mu)\n    \n    #Metropolis Hastings\n    current_logp <- log_posterior(nuts_state$q, Sigma, mu)\n    proposed_logp <- log_posterior(trajectory$q, Sigma, mu)\n  \n    if(runif(1) < acceptance_prob(current_logp, proposed_logp)){\n      nuts_state$q <- trajectory$q\n    }\n    \n    samples[i + n_warmup, ] <- nuts_state$q\n  }\n  \n  samples\n}\n```\n:::\n\n\n\nHere's a breakdown of the full nuts function:\n\n1.  **Initialization**: We initialize the NUTS state using the `nuts_init()` function.\n2.  **Warmup**: The first `n_warmup` iterations are used for tuning the step size. A very basic adaptation is implemented, increasing the step size in the first half of the warmup and decreasing it in the second half. More sophisticated methods exist (like dual averaging).\n3.  **Sampling**: The main sampling loop runs for `n_samples` iterations. In each iteration:\n    -  We build a trajectory using `build_trajectory()`.\n    -  We perform the Metropolis Hastings step, to accept or reject the new proposed sample\n    -  We store the current position in the `samples` matrix.\n\nThis implementation provides a basic but functional NUTS sampler. In the next section, we'll discuss diagnostics and validation to ensure our sampler is working correctly.\n\nOkay, let's move on to the \"Diagnostics and Validation\" section, starting with \"Visual Diagnostics.\"\n\n# Is Our Sampler Behaving Itself?\n\nIn the following section, we'll try to estimate the location parameters of a 2-dimensional multivariate normal, we'll call them $\\theta_1$ and $\\theta_2$ respectively. They will have a true values of $\\theta_1 = 1$ and $\\theta_2 = -1$, and the variance-covariance matrix ($\\Sigma$) will be defined as:\n\n$$\n\\Sigma = \n  \\begin{pmatrix} \n    1.0 & 0.5 \\\\ \n    0.5 & 1.0\n  \\end{pmatrix}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n## Initial parameters\nq0 <- c(0, 0)    # Starting positions\nmu <- c(1, -1)   # Target location of the distribution\nepsilon <- 0.5   # (Initial) Step size for HMC exploring\nlambda_ta <- .75 # Target acceptance rate\ngamma <- 0.5     # Adaptation rate for epsilon\n\n# Variance-Covariance Matrix\nSigma <- matrix(\n  data = c(1, 0.5, \n           0.5, 1), \n  nrow = 2\n)\n\nset.seed(1234) # Seed for reproducibility\n\n# Our main function — HMC-NUTS sampler\nsamples <- nuts(\n  log_posterior, grad_log_posterior,         # Distribution functions\n  q0, Sigma, mu,                             # Target parameters\n  epsilon, lambda_ta, gamma,\n  n_samples = 2000, n_warmup = 2000 # Sampler hyperparameter\n)\n```\n:::\n\n\n\nNow that we have a working NUTS sampler, we need to make sure it's actually doing what it's supposed to do. This section will cover several diagnostic techniques, both visual and numerical, to validate our sampler.\n\n#### Visual Diagnostics\n\nThe first step in diagnosing our sampler is to visualize the results. This gives us a quick and intuitive understanding of its behavior. Two common visual diagnostics are trace plots and posterior density estimates.\n\n##### Trace Plots\n\nTrace plots show the value of each parameter over the course of the sampling process. Ideally, trace plots should look like \"white noise\" (random fluctuations around a stable mean). This indicates that the sampler is exploring the posterior well and not getting stuck in any particular region. If you see trends, patterns, or long periods of near-constant values, it could indicate problems with convergence.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nplot_df <- as.data.table(samples)\nplot_df[, iter := seq_len(.N)]\n\nplot_df <- melt(plot_df, id.vars = \"iter\")\n\nggplot(plot_df, aes(iter, value, col = variable)) +\n  annotate(geom = \"ribbon\", alpha = 1/5,\n           x = c(0, 2000), ymin = -Inf, ymax = Inf) +\n  annotate(geom = \"text\", x = 1950, y = -4, \n           label = \"\\\"Burn-in\\\" Period\", hjust = 1) +\n  geom_line(linewidth = 1/2) +\n  geom_hline(yintercept = c(-1,1), linetype = 2) +\n  labs(color = \"Parameter\", y = expression(theta), x = \"Iterations\",\n       title = \"Traceplot of Parameter Values\",\n       subtitle = \"Over Effective and Burn-in Samples\") +\n  scale_color_manual(values = c(rgb(0,.5,.5,1),rgb(.5,0,.5,1)),\n                     labels = c(\"theta[1]\", \"theta[2]\") |> \n                       scales::label_parse()()) +\n  scale_y_continuous(expand = c(0.1,0)) +\n  scale_x_continuous(expand = c(0,0))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.svg)\n:::\n:::\n\n\n\n##### Posterior Density Estimates \n\nThese plots show the estimated density of the samples, giving us an idea of the shape of the posterior distribution. We can compare these estimates to the true posterior distribution (if we know it) to check if our sampler is capturing the correct shape.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#True density\nxy_seq <- seq(-4, 4, by = .1)\ndens_df <- expand.grid(x = xy_seq, y = xy_seq)\ndens_df$z <- mvtnorm::dmvnorm(dens_df, mu, Sigma)\n\nggplot(data = data.frame(samples), aes(x = X1, X2))+\n  geom_contour(data = dens_df, aes(x, y, z = z), \n               col = \"gray40\", linetype = 2) +\n  geom_path(alpha = .2, col = \"gray\") +\n  geom_point(col = rgb(0,0.5,0.5,1), alpha = 1/5, pch = 16) +\n  labs(x = expression(theta[2]), y = expression(theta[1]),\n       title = expression(\"Joint Posterior Distribution of\"~theta))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.svg)\n:::\n:::\n\n\n\nBy visually inspecting these plots, we can get a good sense of whether our NUTS sampler is working as expected. However, visual diagnostics are subjective. We also need numerical diagnostics to provide more objective measures of sampler performance. We'll cover these in the next subsection.\n\n#### Numerical Diagnostics\n\nWhile visual diagnostics provide a valuable qualitative assessment of our sampler's performance, we also need quantitative metrics to be more objective. Two key numerical diagnostics are effective sample size (ESS) and R-hat ($\\hat{R}$).\n\n##### Effective Sample Size (ESS)\n\nThe ESS measures the number of *independent* samples that our sampler has effectively generated. Because MCMC samples are correlated, the ESS is typically smaller than the actual number of samples. A higher ESS indicates better sampler efficiency. A rule of thumb is that you want an ESS of at least a few hundred for each parameter to have reliable estimates of the posterior.\n\nWe can estimate the ESS using various methods. A common approach is to use the `effectiveSize()` function from the `coda` package in R:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate ESS for each parameter\ncoda::mcmc(samples, start = 2000 + 1) |> \n  coda::effectiveSize()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    var1     var2 \n511.6659 508.3677 \n```\n\n\n:::\n:::\n\n\n\n##### Gelman and Rubin's Convergence Diagnostic ($\\hat{R}$)\n\nThe $\\hat{R}$ statistic (pronounced \"R-hat\") is a convergence diagnostic that compares the variance within multiple chains to the variance between chains. If the chains have converged to the same distribution, the within-chain variance should be similar to the between-chain variance, and $\\hat{R}$ should be close to 1. Values of $\\hat{R}$ much greater than 1 (e.g., above 1.1) indicate that the chains have not converged.\n\nHowever, to compute $\\hat{R}$ we need more than one chain, so let's run our HMC-NUTS model four times to get independent runs or \"chains\":\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nn_chains <- 4 # Number of independent chains\n\nset.seed(1234) # Seed for reproducibility\n\n# Our main function within a lapply() statement for looping\nnuts_model <- lapply(seq_len(n_chains), function(x) {\n  samples <- nuts(\n    log_posterior, grad_log_posterior,\n    q0, Sigma, mu,\n    epsilon, lambda_ta, gamma,\n    n_samples = 2000, n_warmup = 2000\n  )\n  `dimnames<-`(samples, list(NULL, c(\"theta_1\", \"theta_2\")))\n})\n```\n:::\n\n\n\nWe can now calculate $\\hat{R}$ using the `gelman.diag()` function from the coda package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate R-hat\nnuts_model |> \n  lapply(coda::mcmc, start = 2e3 + 1) |> \n  coda::mcmc.list() |> \n  coda::gelman.diag() |> \n  lapply(round,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$psrf\n        Point est. Upper C.I.\ntheta_1      1.003      1.009\ntheta_2      1.001      1.003\n\n$mpsrf\n[1] 1.004\n```\n\n\n:::\n:::\n\n\n\nAs you can see, all $\\hat{R}$ are well below the 1.1 threshold, which suggests thta the chains are mixing well enough.\n\nWith these visual and numerical diagnostics, we can be confident in the performance of our NUTS sampler. These tools allow us to assess convergence, efficiency, and overall sampler behavior, ensuring that we are obtaining reliable samples from our target posterior distribution. \n\n# Making It Sing in the Real World\n\nNow that we have a basic NUTS sampler, let's talk about how to fine-tune it for real-world applications. Because, let's face it, toy examples are fun, but real-world problems are where the real challenges (and rewards) lie.\n\n#### Practical Considerations\n\nWhen applying NUTS to real-world problems, there are a few practical considerations to keep in mind: choosing an initial step size, setting the maximum tree depth, and understanding the computational trade-offs.\n\n##### Choosing an Initial Step Size\n\nWhile NUTS adapts the step size during warmup, a good initial step size can significantly improve the efficiency of the adaptation process. A common approach is to perform a short pilot run (a few hundred iterations) and adjust the initial step size based on the acceptance rate. If the acceptance rate is too low (e.g., below 0.6), decrease the initial step size. If it's too high (e.g., above 0.9), increase it.\n\nIn our implementation, we used a very simple adaptation strategy. In real-world applications, more robust methods like dual averaging are used. These methods are more stable and efficient at finding a good step size.\n\n##### Setting the Maximum Tree Depth\n\nThe maximum tree depth limits the maximum trajectory length that NUTS will explore. A larger tree depth allows for longer trajectories, which can be beneficial for exploring complex posteriors. However, it also increases exponentially the computational cost. A common default value is 10, which allows for trajectories up to $2^{10} = 1024$ leapfrog steps.\n\nIt is important to notice that a too small tree depth can lead to poor exploration of the parameter space, and a too large tree depth can lead to unnecessary computational burden. Therefore, it is important to choose a tree depth that is appropriate for the problem at hand.\n\n##### Computational Trade-offs\n\nNUTS, like other HMC methods, involves computational trade-offs between memory, runtime, and efficiency. Longer trajectories (achieved by larger tree depths or smaller step sizes) can lead to better exploration and lower autocorrelation but also increase the runtime and memory usage. It's important to find a balance that works for your specific problem and computational resources.\n\nHere's a summary of the trade-offs:\n\n*   **Larger tree depth:** Longer trajectories, better exploration, higher runtime, higher memory usage.\n*   **Smaller step size:** More accurate trajectories, better exploration (up to a point), higher runtime.\n\nIn practice, you'll often need to experiment with different settings to find the optimal balance for your problem. This might involve running several short test runs with different parameter values and comparing the results.\n\n#### When Things Go Wrong\n\nEven with its adaptive nature, NUTS can sometimes struggle with certain types of posterior distributions. This subsection will discuss some common pitfalls and techniques to address them.\n\n##### Pathological Posteriors\n\nCertain characteristics of posterior distributions can make sampling challenging for any MCMC method, including NUTS. Some of the most common culprits are:\n\n-   **Extreme Curvature:** If the posterior has regions of very high curvature (sharp turns or narrow valleys), NUTS might have trouble navigating these areas. The leapfrog integrator can become inaccurate, leading to poor exploration.\n-   **Multimodality:** As we discussed earlier, multimodal posteriors (with multiple peaks) can be difficult for any sampler. NUTS can sometimes get stuck in one mode and fail to explore the others.\n-   **Discontinuities or Sharp Changes:** If the posterior has discontinuities or sharp changes in density, the gradient information used by NUTS can be misleading, leading to inefficient sampling.\n\n##### Techniques to Stabilize NUTS\n\nWhen faced with these challenging posteriors, there are several techniques you can try to stabilize NUTS:\n\n-   **Reparameterization:** Sometimes, reparameterizing the model can make the posterior easier to sample. This involves transforming the parameters of the model to a new set of parameters that result in a smoother or more well-behaved posterior. For example, if you have a parameter that is constrained to be positive, you could reparameterize it using a logarithmic transformation.\n-   **Increasing Tree Depth:** Increasing the maximum tree depth can allow NUTS to explore more complex trajectories and potentially escape from narrow valleys or explore different modes. However, this comes at the cost of increased computational cost.\n-   **Using a More Robust Step Size Adaptation:** As mentioned before, using more sophisticated methods for step size adaptation, like dual averaging, can significantly improve NUTS's performance. These methods are less sensitive to the initial step size and can adapt more efficiently to the local geometry of the posterior.\n-   **Prior Choice:** In some cases, a carefully chosen prior distribution can help to regularize the posterior and make it easier to sample.\n\nIt's important to remember that there's no one-size-fits-all solution for these problems. You'll often need to experiment with different techniques to find what works best for your specific problem. Careful diagnostics, both visual and numerical, are crucial for identifying potential issues and evaluating the effectiveness of your solutions.\n\n#### Taking It to the Next Level\n\nWe've covered the basics of NUTS implementation and fine-tuning. Now, let's explore some advanced tips for using NUTS in more complex scenarios and leveraging existing tools.\n\n##### Standing on the Shoulders of Giants\n\nImplementing NUTS from scratch, as we've done in this post, is a great way to understand its inner workings. However, for most real-world applications, it's recommended to use well-established probabilistic programming languages that have highly optimized and thoroughly tested NUTS implementations. Some popular choices include:\n\n-   **Stan:** Stan is a powerful probabilistic programming language specifically designed for Bayesian modeling. It features a highly optimized implementation of NUTS, along with many other advanced features like automatic differentiation and robust step size adaptation (using dual averaging). Stan is often the go-to choice for serious Bayesian work.\n-   **PyMC:** PyMC is a Python library for Bayesian statistical modeling. It provides a user-friendly interface for building and fitting Bayesian models, including NUTS sampling. PyMC is a good option if you prefer working in Python.\n-   **Turing.jl:** Turing.jl is a probabilistic programming language written in Julia. It also provides an efficient implementation of NUTS, and Julia's performance makes it a good option for computationally intensive models.\n\nUsing these tools saves you the trouble of implementing NUTS yourself and gives you access to highly optimized and robust implementations.\n\n##### The Future of NUTS\n\nThe field of Bayesian computation is constantly evolving, and there are several exciting innovations related to NUTS:\n\n-   **GPU Acceleration:** Recent research has focused on accelerating NUTS using GPUs. This can significantly speed up sampling, especially for high-dimensional models. Libraries like NumPyro (built on JAX) and some developments in Stan are exploring this direction.\n-   **Improved Step Size Adaptation:** Researchers are continually developing more efficient and robust methods for step size adaptation. These methods aim to improve the performance of NUTS in challenging scenarios.\n-   **Variations of NUTS:** There are also variations of NUTS that aim to address specific challenges, such as sampling from posteriors with very high curvature.\n\nThese advanced tips can help you take your Bayesian modeling to the next level. Using established tools like Stan, PyMC, or Turing.jl will save you time and provide access to highly optimized implementations. Keeping up with recent innovations can further improve your sampling efficiency and allow you to tackle even more complex problems.\n\n# Where Do We Go From Here?\n\nWe've explored the depths of NUTS, from its underlying principles to its implementation and fine-tuning. But the journey doesn't end here. NUTS is a powerful tool with broad applicability, and there are still many exciting avenues for exploration and development.\n\n#### Expanding the Horizons of NUTS\n\nNUTS truly shines when applied to complex Bayesian models that pose significant challenges for traditional MCMC methods. Here are some key areas where NUTS has proven particularly valuable.\n\n##### Hierarchical Models\n\nHierarchical models, with their nested structures and multiple levels of uncertainty, are notoriously difficult to sample from. NUTS's ability to efficiently explore high-dimensional spaces and adapt to complex geometries makes it an ideal choice for these models. Whether you're modeling population dynamics, analyzing clinical trial data, or building complex econometric models, NUTS can handle the intricate dependencies inherent in hierarchical structures.\n\n##### Non-Conjugate Priors\n\nIn Bayesian modeling, we often choose conjugate priors for mathematical convenience. However, these priors might not always be the most appropriate for our problem. Non-conjugate priors, while more flexible, often lead to intractable posteriors that are difficult to sample from. NUTS, with its gradient-based approach, can effectively handle these non-conjugate scenarios, allowing us to use more realistic and flexible priors.\n\n##### High-Dimensional Spaces\n\nAs the number of parameters in our model increases, the dimensionality of the posterior space grows rapidly. This can make sampling extremely challenging for traditional MCMC methods. NUTS's efficient exploration and adaptive trajectory length make it well-suited for high-dimensional problems. Whether you're working with image analysis, genomics data, or large-scale machine learning models, NUTS can help you navigate these vast parameter spaces.\n\nThese are just a few examples of the many areas where NUTS can be applied. Its versatility and efficiency make it a valuable tool for a wide range of Bayesian modeling tasks.\n\n#### Your Turn to Go NUTS!\n\nNow that you've grasped the core concepts and implementation of NUTS, I want to leave you with an open challenge: how would you adapt NUTS to your own specific problems?\n\nThink about the types of models you work with. Do you encounter any of the challenges we've discussed, such as high dimensionality, complex geometries, or non-conjugate priors? How could you leverage NUTS to improve your sampling efficiency and obtain more reliable results?\n\nHere are some questions to consider:\n\n-   **What types of posterior distributions do you typically encounter?** Are they relatively simple and well-behaved, or do they exhibit complex features like multimodality or high curvature?\n-   **What are the computational constraints of your problems?** Do you have limited memory or runtime, which might influence your choice of tree depth or other NUTS parameters?\n-   **Could reparameterization help to improve sampling in your models?** Are there any transformations you could apply to your parameters to make the posterior smoother or more amenable to NUTS?\n-   **Are there any specific adaptations or extensions of NUTS that might be relevant to your work?** For example, if you're working with very high-dimensional models, you might consider exploring GPU-accelerated NUTS implementations.\n\nDon't be afraid to experiment and try different approaches. The best way to learn is by doing. Implement NUTS in your own projects, explore different parameter settings, and carefully analyze the results. You might discover new and creative ways to apply this powerful sampling technique.\n\nThis is an open invitation to push the boundaries of Bayesian computation and contribute to the ongoing development of efficient and robust sampling methods.\n\n#### Looking Ahead\n\nThis post has provided a deep dive into the No-U-Turn Sampler, from its theoretical foundations to its practical implementation in R. We've seen how NUTS addresses the limitations of traditional MCMC methods and fixed-step HMC, offering a powerful and efficient approach to Bayesian inference.\n\nBut the world of Bayesian statistics is constantly evolving, and there's always more to learn, like **Hierarchical Modeling** and demonstrate how NUTS can be effectively applied to these complex structures. Or maybe  we can mess around with **Stan code** directly to gain performance.\n\nI hope this post has given you a solid understanding of NUTS and inspired you to explore its potential in your own work. Stay tuned for future posts as we continue to dig into the fascinating world of Bayesian statistics!\n\n# Appendix {.appendix}\n\n[Here](hmc-nuts-functions.R) is the file with all the R functions used in this blog post. Feel free to use and modify them according to your needs. Happy coding!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}